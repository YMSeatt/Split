
"""
# --- QuizScoreDialog needs significant changes for v51 ---
class QuizScoreDialog(simpledialog.Dialog):
    def __init__(self, parent, title, initial_quiz_name, mark_type_configs, quiz_templates, default_num_questions, initial_num_questions):
        self.initial_quiz_name = initial_quiz_name
        self.mark_type_configs = sorted(mark_type_configs, key=lambda mt: (mt.get("is_extra_credit", False), mt.get("name", ""))) # Sort for consistent display
        self.quiz_templates = quiz_templates
        self.default_num_questions = default_num_questions
        initial_num_questions_var = initial_num_questions
                

        self.quiz_name_var = tk.StringVar(value=initial_quiz_name)
        if initial_num_questions_var == default_num_questions:
            self.num_questions_var = tk.IntVar(value=default_num_questions)
        else:
            self.num_questions_var = tk.IntVar(value=initial_num_questions)
        self.template_var = tk.StringVar() # For selected template name
        self.initial_num_questions_var = tk.IntVar(value=initial_num_questions)
        self.mark_vars2 = {} # {mark_type_id: tk.StringVar()}
        for mt in self.mark_vars2:
            self.mark_vars2[mt["id"]] = tk.StringVar()
        
        for i, mt_config in enumerate(self.mark_vars2):
            label_text = mt_config["name"]
            if mt_config.get("is_extra_credit"): label_text += " (Bonus)"
            
            self.mark_vars2[mt_config["id"]]

        self.mark_vars = {} # {mark_type_id: tk.StringVar()}
        for mt in self.mark_type_configs:
            self.mark_vars[mt["id"]] = tk.StringVar()

        self.comment_text_widget = None
        super().__init__(parent, title)

    def body(self, master):
        main_frame = ttk.Frame(master); main_frame.grid(sticky="nsew",column=0,row=0, padx=10, pady=10)

        # Quiz Name and Number of Questions
        name_q_frame = ttk.Frame(main_frame); name_q_frame.pack(fill=tk.X, pady=(0,10))
        ttk.Label(name_q_frame, text="Quiz Name:").grid(row=0, column=0, sticky="w", padx=(0,5))
        self.quiz_name_entry = ttk.Entry(name_q_frame, textvariable=self.quiz_name_var, width=30)
        self.quiz_name_entry.grid(row=0, column=1, sticky="ew", padx=(0,10))
        name_q_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(name_q_frame, text="# Questions:").grid(row=0, column=2, sticky="w", padx=(10,5))
        self.num_questions_spinbox = ttk.Spinbox(name_q_frame, from_=1, to=200, textvariable=self.num_questions_var, width=5)
        self.num_questions_spinbox.grid(row=0, column=3, sticky="w")

        # Quiz Templates (Optional)
        if self.quiz_templates:
            template_frame = ttk.Frame(main_frame); template_frame.pack(fill=tk.X, pady=(0,10))
            ttk.Label(template_frame, text="Load Template:").grid(row=0, column=0, sticky="w", padx=(0,5))
            template_names = [""] + [tpl["name"] for tpl_id, tpl in sorted(self.quiz_templates.items(), key=lambda item: item[1]['name'])]
            self.template_combo = ttk.Combobox(template_frame, textvariable=self.template_var, values=template_names, width=28, state="readonly")
            self.template_combo.grid(row=0, column=1, sticky="ew")
            template_frame.grid_columnconfigure(1, weight=1)
            self.template_combo.bind("<<ComboboxSelected>>", self.apply_quiz_template)
        
        # Mark Entry Fields (Dynamically created)
        marks_frame = ttk.LabelFrame(main_frame, text="Enter Scores by Mark Type", padding=10)
        marks_frame.pack(fill=tk.BOTH, expand=True, pady=(0,10))
        marks_frame.grid_columnconfigure(1, weight=1) # Allow entry fields to expand
        self.target_entry2 = []
        self.target_entry3 = []
        self.cte = -1
        
        for i, mt_config in enumerate(self.mark_type_configs):
            
            label_text = mt_config["name"]
            if mt_config.get("is_extra_credit"): label_text += " (Bonus)"
            ttk.Label(marks_frame, text=f"{label_text}:").grid(row=i, column=0, sticky="w", pady=3, padx=5)
            entry = ttk.Entry(marks_frame, textvariable=self.mark_vars[mt_config["id"]], width=10)
            entry.grid(row=i, column=1, sticky="ew", pady=3, padx=5)
            entry.bind("<FocusIn>", lambda x=i,x2=i: self.set_numpad(x,x2))
            self.target_entry2.append(self.mark_vars[mt_config["id"]])
            self.target_entry3.append(mt_config["name"])
            self.cte = i
            self.tte = i
            
            
            # Could add default points as placeholder or helper text here
        #print(self.tte)
        #self.cte -=1
        #print((self.mark_type_configs))
        #print(self.mark_vars[mt["mark2"]]) # type: ignore
        #print(self.mark_vars[mt_config["id"]]) # type: ignore
        
        #self.keypad_frame = NumericKeypad(master, self.mark_vars[mt_config["id"]],self.mark_type_configs, allow_decimal=True) # type: ignore
        #self.keypad_frame.pack(padx=(10,5), pady=5,side=tk.RIGHT, fill=tk.BOTH)
        self.keypad_frame = ttk.Frame(master, relief='sunken',borderwidth=10)
        self.keypad_frame.grid(sticky="nsew",column=1,row=0)
        self.keypad_frame.grid_propagate(True)
        self.allow_decimal = True
        self.mark_vars2 = {} # {mark_type_id: tk.StringVar()}
        for mt in self.mark_vars2:
            self.mark_vars2[mt["id"]] = tk.StringVar()
        
        for i, mt_config in enumerate(self.mark_vars2):
            label_text = mt_config["name"]
            if mt_config.get("is_extra_credit"): label_text += " (Bonus)"
        
        self.target_entry = self.mark_vars[mt_config["id"]]
        self.target_entry_name = mt_config["name"]
        #print(self.target_entry_name)
        self.target_name_label = ttk.Label(self.keypad_frame,text=self.target_entry_name)
        self.target_name_label.grid(column=0,row=0,columnspan=9)
        self._next_entry()
        
        buttons = [('7',1,0),('8',1,1),('9',1,2),('4',2,0),('5',2,1),('6',2,2),('1',3,0),('2',3,1),('3',3,2),('0',4,0),('.',4,1) if self.allow_decimal else (' ',4,1),('⌫',4,2),('/',2,3)]
        button_font = ('TkDefaultFont', 15)
        
        for i in range(4): self.rowconfigure(i, minsize=2000,weight=1)
        for i in range(4): self.columnconfigure(i, weight=1)
        for (text, r, c) in buttons:
            if text == ' ': continue
            action = lambda x=text: self._on_press(x)
            ttk.Button(self.keypad_frame, text=text, command=action, style="Keypad.TButton",padding=17,width=5).grid(row=r, column=c, padx=1, pady=1, sticky="nsew")
        ttk.Button(self.keypad_frame, text="Clear", command=self._clear_entry, style="Keypad.TButton").grid(row=1, column=3, padx=1, pady=1, sticky="nsew")
        ttk.Button(self.keypad_frame, text='Next', command=self._next_entry, style="Keypad.TButton").grid(row=4,column=3,padx=1,pady=1,sticky='nsew')
        ttk.Button(self.keypad_frame, text='Previous', command=self._previous_entry, style="Keypad.TButton").grid(row=3,column=3,padx=1,pady=1,sticky='nsew')
        s = ttk.Style(); s.configure("Keypad.TButton", font=button_font, padding=(5,10),height=100)
    
        
        
        
        #print(self.mark_type_configs)
        #main_frame.columnconfigure(2, weight=0)
        # Comment
        comment_frame = ttk.LabelFrame(main_frame, text="Comment (Optional)", padding=5)
        comment_frame.pack(fill=tk.X, pady=(0,5))
        self.comment_text_widget = tk.Text(comment_frame, width=45, height=3, wrap=tk.WORD)
        self.comment_text_widget.pack(fill=tk.X, expand=True)

        self.quiz_name_entry.focus_set()
        return self.quiz_name_entry
    def _on_press(self, key):
        current_text = self.target_entry.get()
        if key == '⌫': n = len(current_text)-1; self.target_entry.set(current_text[0:n])
        elif key == '.':
            if self.allow_decimal and '.' not in current_text: self.target_entry.set(self.target_entry.get()+ key)
        else: self.target_entry.set(self.target_entry.get()+ key)
        
    def _clear_entry(self): self.target_entry.set("")
    def _next_entry(self):
        if self.cte < self.tte: self.cte +=1
        else: self.cte = 0
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
        
    def _previous_entry(self):
        if self.cte < self.tte and self.cte > -2: self.cte -=1
        else: self.cte = (self.tte-1)
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
        
    def set_numpad(self, event, x):
        #print(x)
        self.cte = x
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
        
    def apply_quiz_template(self, event=None):
        selected_template_name = self.template_var.get()
        if not selected_template_name: return # No template selected

        template_id_found = None
        for tpl_id, tpl_data in self.quiz_templates.items():
            if tpl_data["name"] == selected_template_name:
                template_id_found = tpl_id
                break

        if template_id_found:
            template = self.quiz_templates[template_id_found]
            self.quiz_name_var.set(template.get("quiz_name_override", self.quiz_name_var.get())) # Update quiz name if in template
            self.num_questions_var.set(template.get("num_questions", self.num_questions_var.get()))
            for mt_id, mark_var in self.mark_vars.items():
                mark_var.set(template.get("default_marks", {}).get(mt_id, "")) # Set default scores for marks

    def validate(self):
        quiz_name = self.quiz_name_var.get().strip()
        if not quiz_name:
            messagebox.showwarning("Input Error", "Quiz name is required.", parent=self)
            return False
        try:
            num_q = self.num_questions_var.get()
            if num_q < 1:
                messagebox.showwarning("Input Error", "Number of questions must be at least 1.", parent=self)
                return False
        except tk.TclError:
            messagebox.showwarning("Input Error", "Number of questions must be a valid number.", parent=self)
            return False

        # Validate mark entries (ensure they are numbers if filled)
        for mt_id, mark_var in self.mark_vars.items():
            val_str = mark_var.get().strip()
            if val_str: # Only validate if not empty
                try:
                    float(val_str) # Check if it can be converted to a number
                except ValueError:
                    mt_name = next((mtc["name"] for mtc in self.mark_type_configs if mtc["id"] == mt_id), mt_id)
                    messagebox.showwarning("Input Error", f"Score for '{mt_name}' must be a number if entered.", parent=self)
                    return False
        return True

    def apply(self):
        if not self.validate():
            self.result = None
            return

        quiz_name_final = self.quiz_name_var.get().strip()
        comment_final = self.comment_text_widget.get("1.0", tk.END).strip()
        num_questions_final = self.num_questions_var.get()
        
        marks_data_final = {}
        for mt_id, mark_var in self.mark_vars.items():
            val_str = mark_var.get().strip()
            if val_str: # Only include marks that were actually entered
                try:
                    marks_data_final[mt_id] = float(val_str) # Store as float
                except ValueError:
                    marks_data_final[mt_id] = val_str # Should not happen if validate passed
            # If a mark type is not entered, it's omitted from marks_data_final

        self.result = (quiz_name_final, marks_data_final, comment_final, num_questions_final)
"""



"""
class SettingsDialog(simpledialog.Dialog):
    def __init__(self, parent, current_settings, custom_behaviors, all_behaviors, app,
                 custom_homework_statuses, all_homework_statuses, # RENAMED
                 custom_homework_types, all_homework_types, # NEW
                 password_manager_instance, theme, custom_canvas_color):
        self.settings = current_settings
        self.custom_behaviors_ref = custom_behaviors
        self.all_behaviors_ref = all_behaviors
        
        # NEW/RENAMED: References to the main app's lists
        self.custom_homework_statuses_ref = custom_homework_statuses
        self.all_homework_statuses_ref = all_homework_statuses
        self.custom_homework_types_ref = custom_homework_types
        self.all_homework_types_ref = all_homework_types
        
        self.app = app
        self.password_manager = password_manager_instance
        self.theme = tk.StringVar(value=theme)
        self.theme2 = self.theme.get()
        self.custom_canvas_color = tk.StringVar(value= custom_canvas_color if custom_canvas_color != None else "Default")
        self.settings_changed_flag = False
        self.initial_settings_snapshot = {k: (v.copy() if isinstance(v, (dict, list)) else v) for k,v in current_settings.items()}
        super().__init__(parent, f"Settings - {APP_NAME}")

    def body(self, master):
        self.master_frame = master # Keep a reference for rebuilding tabs if needed
        self.notebook = ttk.Notebook(master)
        
        # --- General Tab ---
        general_tab = ttk.Frame(self.notebook, padding=10); self.notebook.add(general_tab, text="General")
        self.create_general_tab(general_tab)

        # --- Student Display Tab ---
        student_display_tab = ttk.Frame(self.notebook, padding=10); self.notebook.add(student_display_tab, text="Student Boxes")
        self.create_student_display_tab(student_display_tab)

        # --- Behavior/Quiz Log Tab ---
        behavior_log_tab = ttk.Frame(self.notebook, padding=10); self.notebook.add(behavior_log_tab, text="Behavior & Quiz")
        self.create_behavior_log_tab(behavior_log_tab)

        # --- Homework Log Tab (New) ---
        homework_log_tab = ttk.Frame(self.notebook, padding=10); self.notebook.add(homework_log_tab, text="Homework")
        self.create_homework_log_tab(homework_log_tab)

        # --- Data & Export Tab ---
        data_export_tab = ttk.Frame(self.notebook, padding=10); self.notebook.add(data_export_tab, text="Data & Export")
        self.create_data_export_tab(data_export_tab)

        # --- Security Tab ---
        security_tab = ttk.Frame(self.notebook, padding=10); self.notebook.add(security_tab, text="Security")
        self.create_security_tab(security_tab)

        # --- Advanced/Hidden Tab (Optional) ---
        # self.create_advanced_tab(advanced_tab)

        self.notebook.grid(column=0,row=0,columnspan=2)
        self.notebook.grid_propagate(True)
        # No specific focus needed, first field in first tab will get it.
        return self.notebook

    def create_general_tab(self, tab_frame):
        lf = ttk.LabelFrame(tab_frame, text="Application Behavior", padding=10); lf.pack(fill=tk.X, pady=5)
        # Autosave interval
        ttk.Label(lf, text="Autosave Interval (seconds):").grid(row=0, column=0, sticky=tk.W, padx=5, pady=3)
        self.autosave_interval_var = tk.IntVar(value=self.settings.get("autosave_interval_ms", 30000) // 1000)
        ttk.Spinbox(lf, from_=10, to=300, increment=10, textvariable=self.autosave_interval_var, width=5).grid(row=0, column=1, sticky=tk.W, padx=5, pady=3)

        # Grid snap
        self.grid_snap_var = tk.BooleanVar(value=self.settings.get("grid_snap_enabled", False))
        ttk.Checkbutton(lf, text="Enable Snap to Grid during Drag", variable=self.grid_snap_var).grid(row=1, column=0, columnspan=2, sticky=tk.W, padx=5, pady=3)
        ttk.Label(lf, text="Grid Size (pixels):").grid(row=2, column=0, sticky=tk.W, padx=5, pady=3)
        self.grid_size_var = tk.IntVar(value=self.settings.get("grid_size", DEFAULT_GRID_SIZE))
        ttk.Spinbox(lf, from_=5, to=100, increment=5, textvariable=self.grid_size_var, width=5).grid(row=2, column=1, sticky=tk.W, padx=5, pady=3)

        # Student Groups Enabled
        self.groups_enabled_var = tk.BooleanVar(value=self.settings.get("student_groups_enabled", True))
        ttk.Checkbutton(lf, text="Enable Student Groups Feature", variable=self.groups_enabled_var).grid(row=3, column=0, columnspan=2, sticky=tk.W, padx=5, pady=3)
        
        # Zoom Level Display
        self.show_zoom_var = tk.BooleanVar(value=self.settings.get("show_zoom_level_display", True))
        ttk.Checkbutton(lf, text="Show Zoom Level % Display on Main Screen", variable=self.show_zoom_var).grid(row=4, column=0, columnspan=2, sticky=tk.W, padx=5, pady=3)

        # Max Undo History Days
        ttk.Label(lf, text="Max Undo History (days):").grid(row=5, column=0, sticky=tk.W, padx=5, pady=3)
        self.max_undo_days_var = tk.IntVar(value=self.settings.get("max_undo_history_days", MAX_UNDO_HISTORY_DAYS))
        ttk.Spinbox(lf, from_=1, to=90, textvariable=self.max_undo_days_var, width=5).grid(row=5, column=1, sticky=tk.W, padx=5, pady=3)
        
        # Theme
        ttk.Label(lf, text = "Theme: ").grid(row=6,column=0,sticky='W', padx=5, pady=3)
        
        theme_combo = ttk.Combobox(lf, values = THEME_LIST, textvariable= self.theme, state='readonly')
        theme_combo.grid(row=6, column=1, sticky="W", padx=5, pady=3)
        theme_combo.bind("<<ComboboxSelected>>", self.theme_set)
        theme_combo.set(self.theme.get())
        
        # Canvas Color
        ttk.Label(lf, text = "Canvas color (background): ").grid(row=7,column=0,sticky='W', padx=5, pady=3)
        
        canvas_color_entry = ttk.Entry(lf, textvariable= self.custom_canvas_color)
        canvas_color_entry.grid(row=7, column=1, sticky="W", padx=5, pady=3)
        
        
        #ttk.Label(parent_frame, text="Default Fill Color:").grid(row=start_row,column=0,sticky=tk.W,padx=5,pady=3)
        #fill_var = tk.StringVar(value=self.settings.get(fill_key, DEFAULT_BOX_FILL_COLOR))
        #setattr(self, f"{fill_key}_var", fill_var) # Store var on self
        #ttk.Entry(, textvariable=fill_var, width=12).grid(row=start_row,column=1,sticky=tk.W,padx=5,pady=3)
        
        if self.custom_canvas_color.get() == "":
            #print("Hi")
            #self.custom_canvas_color
            pass
        else:
            #print("Hi2", self.custom_canvas_color.get())
            #print(self.custom_canvas_color)
            self.custom2 = tk.StringVar(value=self.custom_canvas_color.get())
        ttk.Button(lf, text="Choose...", command=lambda v=self.custom_canvas_color: self.choose_color_for_canvas(v)).grid(row=7,column=2,sticky=tk.W,padx=2,pady=3)
        ttk.Button(lf, text="Default", command=lambda v=self.custom_canvas_color: self.reset_canvas_color(v)).grid(row=7,column=3, sticky='W', padx=5, pady=3)
        #theme_combo.bind("<<ComboboxSelected>>", self.theme_set)
        #theme_combo.set(self.theme.get())
        #print(self.theme.get(), "initlial")

    def create_student_display_tab(self, tab_frame):
        lf_defaults = ttk.LabelFrame(tab_frame, text="Default Student Box Appearance", padding=10)
        lf_defaults.grid(sticky="nsew", column=0,row=0, pady=5)
        # Default size
        ttk.Label(lf_defaults, text="Default Width:").grid(row=0,column=0,sticky=tk.W,padx=5,pady=3)
        self.def_stud_w_var = tk.IntVar(value=self.settings.get("default_student_box_width", DEFAULT_STUDENT_BOX_WIDTH))
        ttk.Spinbox(lf_defaults, from_=MIN_STUDENT_BOX_WIDTH, to=500, textvariable=self.def_stud_w_var, width=5).grid(row=0,column=1,sticky=tk.W,padx=5,pady=3)
        ttk.Label(lf_defaults, text="Default Height:").grid(row=1,column=0,sticky=tk.W,padx=5,pady=3)
        self.def_stud_h_var = tk.IntVar(value=self.settings.get("default_student_box_height", DEFAULT_STUDENT_BOX_HEIGHT))
        ttk.Spinbox(lf_defaults, from_=MIN_STUDENT_BOX_HEIGHT, to=300, textvariable=self.def_stud_h_var, width=5).grid(row=1,column=1,sticky=tk.W,padx=5,pady=3)
        # Default colors and font
        self.create_color_font_settings_ui(lf_defaults, 2, "student_box_fill_color", "student_box_outline_color", "student_font_family", "student_font_size", "student_font_color")

        lf_cond_format = ttk.LabelFrame(tab_frame, text="Conditional Formatting Rules", padding=10, width=1000)
        lf_cond_format.grid(sticky="nse", pady=5, padx=5, column=1, columnspan=3, row=0)
        lf_cond_format.grid_anchor("e")
        ttk.Button(lf_cond_format, text="Add Rule...", command=self.add_conditional_rule).pack(pady=3, anchor=tk.W)
        self.rules_listbox = tk.Listbox(lf_cond_format, height=7, exportselection=False, width=75)
        self.rules_listbox.pack(fill=tk.X, expand=True, pady=2)
        self.populate_conditional_rules_listbox()
        rule_btns_frame = ttk.Frame(lf_cond_format); rule_btns_frame.pack(fill=tk.X)
        ttk.Button(rule_btns_frame, text="Edit Selected", command=self.edit_selected_conditional_rule).pack(side=tk.LEFT, padx=2)
        ttk.Button(rule_btns_frame, text="Remove Selected", command=self.remove_selected_conditional_rule).pack(side=tk.LEFT, padx=2)


    def create_behavior_log_tab(self, tab_frame):
        # Recent Incidents Display
        lf_recent = ttk.LabelFrame(tab_frame, text="Recent Incidents on Student Boxes (Behavior/Quiz)", padding=10); lf_recent.grid(sticky="nsew",column=0,row=0, pady=5)
        self.show_recent_var = tk.BooleanVar(value=self.settings.get("show_recent_incidents_on_boxes", True))
        ttk.Checkbutton(lf_recent, text="Show recent incidents on student boxes", variable=self.show_recent_var).grid(row=0,column=0,columnspan=2,sticky=tk.W, padx=5,pady=3)
        ttk.Label(lf_recent, text="Number to show:").grid(row=1,column=0,sticky=tk.W,padx=5,pady=3)
        self.num_recent_var = tk.IntVar(value=self.settings.get("num_recent_incidents_to_show", 2))
        ttk.Spinbox(lf_recent, from_=0, to=10, textvariable=self.num_recent_var, width=3).grid(row=1,column=1,sticky=tk.W,padx=5,pady=3)
        ttk.Label(lf_recent, text="Time window (hours):").grid(row=2,column=0,sticky=tk.W,padx=5,pady=3)
        self.time_window_var = tk.IntVar(value=self.settings.get("recent_incident_time_window_hours", 24))
        ttk.Spinbox(lf_recent, from_=1, to=168, textvariable=self.time_window_var, width=4).grid(row=2,column=1,sticky=tk.W,padx=5,pady=3)
        self.show_full_recent_var = tk.BooleanVar(value=self.settings.get("show_full_recent_incidents", False))
        ttk.Checkbutton(lf_recent, text="Show full behavior names (not initials)", variable=self.show_full_recent_var).grid(row=3,column=0,columnspan=2,sticky=tk.W,padx=5,pady=3)
        self.reverse_order_var = tk.BooleanVar(value=self.settings.get("reverse_incident_order", True))
        ttk.Checkbutton(lf_recent, text="Show most recent incident last (chronological)", variable=self.reverse_order_var).grid(row=4,column=0,columnspan=2,sticky=tk.W,padx=5,pady=3)

        # Custom Behaviors
        lf_custom_b = ttk.LabelFrame(tab_frame, text="Custom Behaviors & Initials", padding=10); lf_custom_b.grid(sticky="nsew",column=1,row=0, pady=5)
        custom_b_btns_frame = ttk.Frame(lf_custom_b); custom_b_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_b_btns_frame, text="Add Behavior...", command=self.add_custom_behavior).pack(side=tk.LEFT, padx=2, pady=3)
        ttk.Button(custom_b_btns_frame, text="Manage Behavior/Quiz Initials...", command=self.manage_behavior_initials).pack(side=tk.LEFT, padx=2, pady=3)
        ttk.Button(custom_b_btns_frame, text="Manage Quiz Mark Types...", command=self.manage_quiz_mark_types).pack(side=tk.LEFT, padx=2, pady=3)


        self.custom_behaviors_listbox = tk.Listbox(lf_custom_b, height=5, exportselection=False)
        self.custom_behaviors_listbox.pack(fill=tk.X, expand=True, pady=(5,2))
        self.populate_custom_behaviors_listbox()
        custom_b_edit_btns_frame = ttk.Frame(lf_custom_b); custom_b_edit_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_b_edit_btns_frame, text="Edit Selected", command=self.edit_selected_custom_behavior).pack(side=tk.LEFT, padx=2)
        ttk.Button(custom_b_edit_btns_frame, text="Remove Selected", command=self.remove_selected_custom_behavior).pack(side=tk.LEFT, padx=2)

        # Quiz Settings
        lf_quiz = ttk.LabelFrame(tab_frame, text="Quiz Logging & Session Settings", padding=10); lf_quiz.grid(sticky="nsew",column=0,row=1, pady=5)
        ttk.Label(lf_quiz, text="Default Quiz Name:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=3)
        self.def_quiz_name_var = tk.StringVar(value=self.settings.get("default_quiz_name", "Pop Quiz"))
        ttk.Entry(lf_quiz, textvariable=self.def_quiz_name_var, width=20).grid(row=0,column=1,sticky=tk.W,padx=5,pady=3)

        ttk.Label(lf_quiz, text="Default #Questions (Manual Log):").grid(row=1, column=0, sticky=tk.W, padx=5, pady=3)
        self.def_quiz_q_var = tk.IntVar(value=self.settings.get("default_quiz_questions",10))
        ttk.Spinbox(lf_quiz, from_=1, to=100, textvariable=self.def_quiz_q_var, width=5).grid(row=1,column=1,sticky=tk.W,padx=5,pady=3)

        ttk.Label(lf_quiz, text="Quiz Name Memory Timeout (mins):").grid(row=2, column=0, sticky=tk.W, padx=5, pady=3)
        self.quiz_timeout_var = tk.IntVar(value=self.settings.get("last_used_quiz_name_timeout_minutes", 60))
        ttk.Spinbox(lf_quiz, from_=0, to=1440, textvariable=self.quiz_timeout_var, width=5).grid(row=2,column=1,sticky=tk.W,padx=5,pady=3)

        self.show_inc_quiz_var = tk.BooleanVar(value=self.settings.get("show_recent_incidents_during_quiz", True))
        ttk.Checkbutton(lf_quiz, text="Show recent behaviors during live quiz", variable=self.show_inc_quiz_var).grid(row=3,column=0,columnspan=2,sticky=tk.W, padx=5,pady=3)
        
        self.combine_marks_display_var = tk.BooleanVar(value=self.settings.get("combine_marks_for_display", True))
        # ttk.Checkbutton(lf_quiz, text="Combine mark counts for log display (e.g., Correct: 8/10)", variable=self.combine_marks_display_var).grid(row=4,column=0,columnspan=2,sticky=tk.W, padx=5,pady=3) # Removed for now, logic complex

        ttk.Button(lf_quiz, text="Quiz Templates...", command=self.app.manage_quiz_templates_dialog).grid(row=0,column=2, padx=10, pady=3, sticky=tk.E)
        lf_quiz.grid_columnconfigure(2, weight=1)

    def create_homework_log_tab(self, tab_frame):
        #"Rebuilt homework tab with clear sections for Types and Statuses."
        
        # --- Column 0: Customization of Lists ---
        customization_frame = tk.Canvas(tab_frame, width=1000)
        customization_frame.grid(row=0, column=1, columnspan=2, rowspan=2, sticky="nsew", padx=(0,10))
        customization_frame.grid_propagate(True)
        customization_frame.grid_columnconfigure(0,weight=1, minsize=600)
        customization_frame.grid_rowconfigure(1,weight=1, minsize=100)
        
        
        # A: Custom Homework TYPES (e.g., "Reading Assignment")
        lf_custom_hw_types = ttk.LabelFrame(customization_frame, text="A: Homework Types", padding=10)
        lf_custom_hw_types.grid(column=0, row=0, sticky='nsew', pady=(0,0))
        ttk.Label(lf_custom_hw_types, text="For simplified & detailed logging, and live sessions.").pack(anchor='w', pady=(0,5))
        
        custom_hw_types_btns_frame = ttk.Frame(lf_custom_hw_types); custom_hw_types_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_hw_types_btns_frame, text="Add Type...", command=self.add_custom_homework_type).pack(side=tk.LEFT, padx=2, pady=2)

        self.custom_hw_types_listbox = tk.Listbox(lf_custom_hw_types, height=5, exportselection=False)
        self.custom_hw_types_listbox.pack(fill=tk.BOTH, pady=(5,2))
        self.populate_custom_homework_types_listbox()
        
        custom_hw_types_edit_btns_frame = ttk.Frame(lf_custom_hw_types); custom_hw_types_edit_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_hw_types_edit_btns_frame, text="Edit Selected", command=self.edit_selected_custom_homework_type).pack(side=tk.LEFT, padx=2)
        ttk.Button(custom_hw_types_edit_btns_frame, text="Remove Selected", command=self.remove_selected_custom_homework_type).pack(side=tk.LEFT, padx=2)

        # B: Custom Homework STATUSES (e.g., "Done", "Late")
        lf_custom_hw_statuses = ttk.LabelFrame(customization_frame, text="B: Homework Statuses", padding=10)
        lf_custom_hw_statuses.grid(column=0, row=1, sticky='nsew', pady=0)
        ttk.Label(lf_custom_hw_statuses, text="For the simplified view's second popup.").pack(anchor='w', pady=(0,5))

        custom_hw_statuses_btns_frame = ttk.Frame(lf_custom_hw_statuses); custom_hw_statuses_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_hw_statuses_btns_frame, text="Add Status...", command=self.add_custom_homework_status).pack(side=tk.LEFT, padx=2, pady=2)
        
        self.custom_hw_statuses_listbox = tk.Listbox(lf_custom_hw_statuses, height=5, exportselection=False)
        self.custom_hw_statuses_listbox.pack(fill=tk.BOTH, expand=True, pady=(5,2))
        self.populate_custom_homework_statuses_listbox()
        
        custom_hw_statuses_edit_btns_frame = ttk.Frame(lf_custom_hw_statuses); custom_hw_statuses_edit_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_hw_statuses_edit_btns_frame, text="Edit Selected", command=self.edit_selected_custom_homework_status).pack(side=tk.LEFT, padx=2)
        ttk.Button(custom_hw_statuses_edit_btns_frame, text="Remove Selected", command=self.remove_selected_custom_homework_status).pack(side=tk.LEFT, padx=2)
        
        # --- Column 1: Other Settings ---
        #settings_frame = ttk.Frame(tab_frame)
        #settings_frame.grid(row=0, column=1, sticky="ns")
        
        
        
        
        # Recent Homework Display
        lf_recent_hw = ttk.LabelFrame(tab_frame, text="Recent Homework on Student Boxes", padding=10)
        lf_recent_hw.grid(sticky="nsew",column=0,row=0, pady=0, padx=10)
        self.show_recent_hw_var = tk.BooleanVar(value=self.settings.get("show_recent_homeworks_on_boxes", True))
        ttk.Checkbutton(lf_recent_hw, text="Show recent homework logs on student boxes", variable=self.show_recent_hw_var).grid(row=0,column=0,columnspan=2,sticky=tk.W, padx=5,pady=3)
        ttk.Label(lf_recent_hw, text="Number to show:").grid(row=1,column=0,sticky=tk.W,padx=5,pady=3)
        self.num_recent_hw_var = tk.IntVar(value=self.settings.get("num_recent_homeworks_to_show", 2))
        ttk.Spinbox(lf_recent_hw, from_=0, to=10, textvariable=self.num_recent_hw_var, width=3).grid(row=1,column=1,sticky=tk.W,padx=5,pady=3)
        ttk.Label(lf_recent_hw, text="Time window (hours):").grid(row=2,column=0,sticky=tk.W,padx=5,pady=3)
        self.time_window_hw_var = tk.IntVar(value=self.settings.get("recent_homework_time_window_hours", 24))
        ttk.Spinbox(lf_recent_hw, from_=1, to=168, textvariable=self.time_window_hw_var, width=4).grid(row=2,column=1,sticky=tk.W,padx=5,pady=3)
        self.show_full_recent_hw_var = tk.BooleanVar(value=self.settings.get("show_full_recent_homeworks", False))
        ttk.Checkbutton(lf_recent_hw, text="Show full homework names (not initials)", variable=self.show_full_recent_hw_var).grid(row=3,column=0,columnspan=2,sticky=tk.W,padx=5,pady=3)
        self.reverse_hw_order_var = tk.BooleanVar(value=self.settings.get("reverse_homework_order", True))
        ttk.Checkbutton(lf_recent_hw, text="Show most recent homework last (chronological)", variable=self.reverse_hw_order_var).grid(row=4,column=0,columnspan=2,sticky=tk.W,padx=5,pady=3)
        
        # Live Homework Session Settings
        lf_live_hw = ttk.LabelFrame(tab_frame, text="Live Homework Session Settings", padding=10)
        lf_live_hw.grid(sticky="nsew", column=0, row=1, pady=0, padx=5)
        ttk.Label(lf_live_hw, text="Default Session Name:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=3)
        self.def_hw_session_name_var = tk.StringVar(value=self.settings.get("default_homework_name", "Homework Check"))
        ttk.Entry(lf_live_hw, textvariable=self.def_hw_session_name_var, width=20).grid(row=0,column=1,sticky=tk.W,padx=5,pady=3)

        ttk.Label(lf_live_hw, text="Session Mode:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=3)
        self.live_hw_mode_var = tk.StringVar(value=self.settings.get("live_homework_session_mode", "Yes/No"))
        hw_mode_combo = ttk.Combobox(lf_live_hw, textvariable=self.live_hw_mode_var, values=["Yes/No", "Select"], state="readonly", width=10)
        hw_mode_combo.grid(row=1, column=1, sticky=tk.W, padx=5, pady=3)
        hw_mode_combo.bind("<<ComboboxSelected>>", self.on_live_hw_mode_change)

        
        # Settings specific to "Yes/No" mode
        self.yes_no_settings_frame = ttk.Frame(lf_live_hw)
        self.yes_no_settings_frame.grid(row=2, column=0, columnspan=3, sticky=tk.EW, padx=5, pady=3)
        # Custom Homework Session Types (for Yes/No mode list)
        lf_custom_hw_session_types = ttk.LabelFrame(self.yes_no_settings_frame, text="Custom Homework Types for 'Yes/No' Session", padding=5)
        lf_custom_hw_session_types.pack(fill=tk.X, pady=3)
        custom_hw_session_btns_frame = ttk.Frame(lf_custom_hw_session_types); custom_hw_session_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_hw_session_btns_frame, text="Add Type...", command=self.add_custom_homework_type).pack(side=tk.LEFT, padx=2, pady=2)
        self.custom_hw_session_types_listbox = tk.Listbox(lf_custom_hw_session_types, height=3, exportselection=False)
        self.custom_hw_session_types_listbox.pack(fill=tk.X, expand=True, pady=(3,2))
        self.populate_custom_homework_types_listbox()
        custom_hw_session_edit_btns_frame = ttk.Frame(lf_custom_hw_session_types); custom_hw_session_edit_btns_frame.pack(fill=tk.X)
        ttk.Button(custom_hw_session_edit_btns_frame, text="Edit Selected", command=self.edit_selected_custom_homework_type).pack(side=tk.LEFT, padx=2)
        ttk.Button(custom_hw_session_edit_btns_frame, text="Remove Selected", command=self.remove_selected_custom_homework_type).pack(side=tk.LEFT, padx=2)


        # Settings specific to "Select" mode
        self.select_mode_settings_frame = ttk.Frame(lf_live_hw)
        # self.select_mode_settings_frame.grid(row=2, column=0, columnspan=3, sticky=tk.EW, padx=5, pady=3) # Positioned by on_live_hw_mode_change
        lf_select_options = ttk.LabelFrame(self.select_mode_settings_frame, text="Options for 'Select' Session Mode", padding=5)
        lf_select_options.pack(fill=tk.X, pady=3)
        # Add UI to manage self.settings["live_homework_select_mode_options"] (list of dicts {"name": "..."})
        # For now, it uses DEFAULT_HOMEWORK_SESSION_BUTTONS. A more complex UI would allow user to customize these.
        ttk.Button(lf_select_options, text="Manage 'Select' Options...", command=self.manage_live_homework_select_options).pack(pady=3, anchor=tk.W)
        

        # General Homework Settings
        self.log_hw_marks_var = tk.BooleanVar(value=self.settings.get("log_homework_marks_enabled", True))
        ttk.Checkbutton(lf_live_hw, text="Enable Detailed Marks for Manual Homework Logging", variable=self.log_hw_marks_var).grid(row=3,column=0,columnspan=3,sticky=tk.W, padx=5,pady=3)
        ttk.Button(lf_live_hw, text="Homework Templates...", command=self.app.manage_homework_templates_dialog).grid(row=0,column=2, padx=10, pady=3, sticky=tk.E)
        lf_live_hw.grid_columnconfigure(2, weight=1)

        #self.on_live_hw_mode_change(None) # Show/hide mode-specific frames


    # --- Methods for managing the new custom lists ---
    
    # Custom Homework TYPES
    def populate_custom_homework_types_listbox(self):
        self.custom_hw_types_listbox.delete(0, tk.END)
        print(self.custom_homework_types_ref)
        for item in self.custom_homework_types_ref:
            self.custom_hw_types_listbox.insert(tk.END, item["name"])
    
    def add_custom_homework_type(self):
        name = simpledialog.askstring("Add Homework Type", "Enter name for the new type (e.g., 'Project Milestone 1'):", parent=self)
        if name and name.strip():
            name = name.strip()
            if any(item["name"].lower() == name.lower() for item in self.custom_homework_types_ref):
                 messagebox.showwarning("Duplicate", f"Type '{name}' already exists.", parent=self); return
            # The concept of a separate ID is now less critical if we just use the name, but good for robustness
            type_id_str, next_id_val = self.app.get_new_custom_homework_type_id() # Reusing this ID generator
            self.app.settings["next_custom_homework_type_id_num"] = next_id_val
            self.custom_homework_types_ref.append({"id": type_id_str, "name": name})
            self.settings_changed_flag = True; self.app.save_custom_homework_types(); self.populate_custom_homework_types_listbox()

    def edit_selected_custom_homework_type(self):
        sel_idx = self.custom_hw_types_listbox.curselection()
        if not sel_idx: return
        idx = sel_idx[0]; old_name = self.custom_homework_types_ref[idx]["name"]
        new_name = simpledialog.askstring("Edit Homework Type", "Enter new name:", initialvalue=old_name, parent=self)
        if new_name and new_name.strip():
            new_name = new_name.strip()
            if new_name.lower() != old_name.lower() and any(item["name"].lower() == new_name.lower() for i, item in enumerate(self.custom_homework_types_ref) if i != idx):
                 messagebox.showwarning("Duplicate", f"Type '{new_name}' already exists.", parent=self); return
            self.custom_homework_types_ref[idx]["name"] = new_name
            self.settings_changed_flag = True; self.app.save_custom_homework_types(); self.populate_custom_homework_types_listbox()
    
    def remove_selected_custom_homework_type(self):
        sel_idx = self.custom_hw_types_listbox.curselection()
        if not sel_idx: return
        if messagebox.askyesno("Confirm Remove", "Remove selected homework type?", parent=self):
            del self.custom_homework_types_ref[sel_idx[0]]
            self.settings_changed_flag = True; self.app.save_custom_homework_types(); self.populate_custom_homework_types_listbox()

    # Custom Homework STATUSES
    def populate_custom_homework_statuses_listbox(self):
        self.custom_hw_statuses_listbox.delete(0, tk.END)
        #self.custom_hw_log_behaviors_listbox
        for item in self.custom_homework_statuses_ref:
            self.custom_hw_statuses_listbox.insert(tk.END, item["name"])

    def add_custom_homework_status(self):
        name = simpledialog.askstring("Add Homework Status", "Enter name for the new status (e.g., 'Excellent Effort'):", parent=self)
        if name and name.strip():
            name = name.strip()
            if any(item["name"].lower() == name.lower() for item in self.custom_homework_statuses_ref):
                 messagebox.showwarning("Duplicate", f"Status '{name}' already exists.", parent=self); return
            self.custom_homework_statuses_ref.append({"name": name})
            self.settings_changed_flag = True; self.app.save_custom_homework_statuses(); self.populate_custom_homework_statuses_listbox()

    def edit_selected_custom_homework_status(self):
        sel_idx = self.custom_hw_statuses_listbox.curselection()
        if not sel_idx: return
        idx = sel_idx[0]; old_name = self.custom_homework_statuses_ref[idx]["name"]
        new_name = simpledialog.askstring("Edit Homework Status", "Enter new name:", initialvalue=old_name, parent=self)
        if new_name and new_name.strip():
            new_name = new_name.strip()
            if new_name.lower() != old_name.lower() and any(item["name"].lower() == new_name.lower() for i, item in enumerate(self.custom_homework_statuses_ref) if i != idx):
                 messagebox.showwarning("Duplicate", f"Status '{new_name}' already exists.", parent=self); return
            self.custom_homework_statuses_ref[idx]["name"] = new_name
            self.settings_changed_flag = True; self.app.save_custom_homework_statuses(); self.populate_custom_homework_statuses_listbox()
            
    def remove_selected_custom_homework_status(self):
        sel_idx = self.custom_hw_statuses_listbox.curselection()
        if not sel_idx: return
        if messagebox.askyesno("Confirm Remove", "Remove selected homework status?", parent=self):
            del self.custom_homework_statuses_ref[sel_idx[0]]
            self.settings_changed_flag = True; self.app.save_custom_homework_statuses(); self.populate_custom_homework_statuses_listbox()


    
    def on_live_hw_mode_change(self, event):
        mode = self.live_hw_mode_var.get()
        if mode == "Yes/No":
            self.select_mode_settings_frame.grid_remove()
            self.yes_no_settings_frame.grid(row=2, column=0, columnspan=3, sticky=tk.EW, padx=5, pady=3)
        elif mode == "Select":
            self.yes_no_settings_frame.grid_remove()
            self.select_mode_settings_frame.grid(row=2, column=0, columnspan=3, sticky=tk.EW, padx=5, pady=3)
        else:
            self.yes_no_settings_frame.grid_remove()
            self.select_mode_settings_frame.grid_remove()

    def create_data_export_tab(self, tab_frame):
        lf_excel = ttk.LabelFrame(tab_frame, text="Excel Export Defaults", padding=10); lf_excel.pack(fill=tk.X, pady=5)
        self.excel_sep_sheets_var = tk.BooleanVar(value=self.settings.get("excel_export_separate_sheets_by_default", True))
        ttk.Checkbutton(lf_excel, text="Separate log types into different sheets by default", variable=self.excel_sep_sheets_var).pack(anchor=tk.W, padx=5, pady=2)
        self.excel_inc_summary_var = tk.BooleanVar(value=self.settings.get("excel_export_include_summaries_by_default", True))
        ttk.Checkbutton(lf_excel, text="Include summary sheet by default", variable=self.excel_inc_summary_var).pack(anchor=tk.W, padx=5, pady=2)

        lf_autosave_excel = ttk.LabelFrame(tab_frame, text="Excel Log Autosave (Experimental)", padding=10); lf_autosave_excel.pack(fill=tk.X, pady=5)
        self.enable_excel_autosave_var = tk.BooleanVar(value=self.settings.get("enable_excel_autosave", False))
        ttk.Checkbutton(lf_autosave_excel, text=f"Enable autosaving log to Excel file ({os.path.basename(AUTOSAVE_EXCEL_FILE)})", variable=self.enable_excel_autosave_var).pack(anchor=tk.W, padx=5, pady=2)
        ttk.Label(lf_autosave_excel, text="Note: This uses current export filters if set, or exports all data. File is overwritten each time.").pack(anchor=tk.W, padx=5, pady=2)


    def create_security_tab(self, tab_frame):
        lf_password = ttk.LabelFrame(tab_frame, text="Application Password", padding=10)
        lf_password.pack(fill=tk.X, pady=5)

        current_pw_set = self.password_manager.is_password_set()
        self.current_pw_status_label = ttk.Label(lf_password, text="Status: Password IS SET" if current_pw_set else "Status: Password NOT SET")
        self.current_pw_status_label.grid(row=0, column=0, columnspan=2, sticky=tk.W, padx=5, pady=5)

        ttk.Label(lf_password, text="New Password:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=3)
        self.new_pw_var = tk.StringVar()
        new_pw_entry = ttk.Entry(lf_password, textvariable=self.new_pw_var, show="*", width=25)
        new_pw_entry.grid(row=1, column=1, sticky=tk.W, padx=5, pady=3)

        ttk.Label(lf_password, text="Confirm New Password:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=3)
        self.confirm_pw_var = tk.StringVar()
        confirm_pw_entry = ttk.Entry(lf_password, textvariable=self.confirm_pw_var, show="*", width=25)
        confirm_pw_entry.grid(row=2, column=1, sticky=tk.W, padx=5, pady=3)

        set_pw_btn = ttk.Button(lf_password, text="Set/Change Password", command=self.set_or_change_password)
        set_pw_btn.grid(row=3, column=0, padx=5, pady=10)
        remove_pw_btn = ttk.Button(lf_password, text="Remove Password", command=self.remove_password, state=tk.NORMAL if current_pw_set else tk.DISABLED)
        remove_pw_btn.grid(row=3, column=1, padx=5, pady=10, sticky=tk.W)
        self.remove_pw_button_ref = remove_pw_btn # To update state

        lf_pw_options = ttk.LabelFrame(tab_frame, text="Password Options", padding=10)
        lf_pw_options.pack(fill=tk.X, pady=5)
        self.pw_on_open_var = tk.BooleanVar(value=self.settings.get("password_on_open", False))
        ttk.Checkbutton(lf_pw_options, text="Require password on application open", variable=self.pw_on_open_var).pack(anchor=tk.W, padx=5, pady=2)
        self.pw_on_edit_var = tk.BooleanVar(value=self.settings.get("password_on_edit_action", False))
        ttk.Checkbutton(lf_pw_options, text="Require password for sensitive actions (add/edit/delete items, layout changes)", variable=self.pw_on_edit_var).pack(anchor=tk.W, padx=5, pady=2)
        
        auto_lock_frame = ttk.Frame(lf_pw_options); auto_lock_frame.pack(fill=tk.X, pady=2)
        self.pw_auto_lock_var = tk.BooleanVar(value=self.settings.get("password_auto_lock_enabled", False))
        ttk.Checkbutton(auto_lock_frame, text="Auto-lock application after inactivity for", variable=self.pw_auto_lock_var).pack(side=tk.LEFT, anchor=tk.W, padx=5)
        self.pw_auto_lock_timeout_var = tk.IntVar(value=self.settings.get("password_auto_lock_timeout_minutes", 15))
        ttk.Spinbox(auto_lock_frame, from_=1, to=120, textvariable=self.pw_auto_lock_timeout_var, width=4).pack(side=tk.LEFT, padx=2)
        ttk.Label(auto_lock_frame, text="minutes").pack(side=tk.LEFT)

        ttk.Label(lf_pw_options, text="For the Master Recovery Password, ask Yaakov Maimon (see Help)", foreground="blue", wraplength=420).pack(anchor=tk.W, padx=5, pady=5)


    def theme_set(self, event):
        #print(self.app.theme_style_using, "old")
        self.app.theme_style_using = self.theme.get()
        self.settings_changed_flag = True
        #print("Theme: ", self.theme.get())
        self.theme2 = self.theme.get()
        #print("theme2", self.theme2)


    def set_or_change_password(self):
        new_pw = self.new_pw_var.get()
        confirm_pw = self.confirm_pw_var.get()
        if not new_pw:
            messagebox.showerror("Password Error", "New password cannot be empty.", parent=self)
            return
        if new_pw != confirm_pw:
            messagebox.showerror("Password Error", "Passwords do not match.", parent=self)
            return
        if len(new_pw) < 4: # Basic length check
            messagebox.showwarning("Weak Password", "Password should be at least 4 characters.", parent=self)
            # Allow user to proceed if they insist
        
        self.password_manager.set_password(new_pw)
        self.settings_changed_flag = True # Settings (hash) changed
        self.new_pw_var.set(""); self.confirm_pw_var.set("")
        self.current_pw_status_label.config(text="Status: Password IS SET")
        self.remove_pw_button_ref.config(state=tk.NORMAL)
        messagebox.showinfo("Password Set", "Application password has been set/changed.", parent=self)

    def prompt_for_password(self, title, prompt_message, for_editing=False):
        if self.password_manager.is_locked:
             if not hasattr(self, '_lock_screen_active') or not self._lock_screen_active.winfo_exists(): self.show_lock_screen()
             return not self.password_manager.is_locked
        if for_editing and not self.settings.get("password_on_edit_action", False) and not self.password_manager.is_password_set(): return True
        if not self.password_manager.is_password_set(): return True
        dialog = PasswordPromptDialog(self.master, title, prompt_message, self.password_manager)
        return dialog.result

    def remove_password(self):
        if self.password_manager.is_password_set():
            if self.prompt_for_password("Confirm Password", "Enter current password to confirm identity", for_editing=True):
                if messagebox.askyesno("Confirm Removal", "Are you sure you want to remove the application password?", parent=self):
                    self.password_manager.set_password(None) # Set to None effectively removes it
                    self.settings_changed_flag = True
                    self.current_pw_status_label.config(text="Status: Password NOT SET")
                    self.remove_pw_button_ref.config(state=tk.DISABLED)
                    self.pw_on_open_var.set(False) # Disable options that require a password
                    self.pw_on_edit_var.set(False)
                    self.pw_auto_lock_var.set(False)
                    messagebox.showinfo("Password Removed", "Application password has been removed.", parent=self)
        else:
            messagebox.showinfo("No Password", "No application password is currently set.", parent=self)
    

    # --- UI Helper for color/font settings ---
    def create_color_font_settings_ui(self, parent_frame, start_row, fill_key, outline_key, font_fam_key, font_size_key, font_color_key):
        # Fill Color
        ttk.Label(parent_frame, text="Default Fill Color:").grid(row=start_row,column=0,sticky=tk.W,padx=5,pady=3)
        fill_var = tk.StringVar(value=self.settings.get(fill_key, DEFAULT_BOX_FILL_COLOR))
        setattr(self, f"{fill_key}_var", fill_var) # Store var on self
        ttk.Entry(parent_frame, textvariable=fill_var, width=12).grid(row=start_row,column=1,sticky=tk.W,padx=5,pady=3)
        ttk.Button(parent_frame, text="Choose...", command=lambda v=fill_var: self.choose_color_for_var(v)).grid(row=start_row,column=2,sticky=tk.W,padx=2,pady=3)
        # Outline Color
        ttk.Label(parent_frame, text="Default Outline Color:").grid(row=start_row+1,column=0,sticky=tk.W,padx=5,pady=3)
        outline_var = tk.StringVar(value=self.settings.get(outline_key, DEFAULT_BOX_OUTLINE_COLOR))
        setattr(self, f"{outline_key}_var", outline_var)
        ttk.Entry(parent_frame, textvariable=outline_var, width=12).grid(row=start_row+1,column=1,sticky=tk.W,padx=5,pady=3)
        ttk.Button(parent_frame, text="Choose...", command=lambda v=outline_var: self.choose_color_for_var(v)).grid(row=start_row+1,column=2,sticky=tk.W,padx=2,pady=3)
        # Font Family
        ttk.Label(parent_frame, text="Default Font Family:").grid(row=start_row+2,column=0,sticky=tk.W,padx=5,pady=3)
        font_fam_var = tk.StringVar(value=self.settings.get(font_fam_key, DEFAULT_FONT_FAMILY))
        setattr(self, f"{font_fam_key}_var", font_fam_var)
        available_fonts = self.settings.get("available_fonts", [DEFAULT_FONT_FAMILY])
        ff_combo = ttk.Combobox(parent_frame, textvariable=font_fam_var, values=available_fonts, width=20, state="readonly")
        ff_combo.grid(row=start_row+2,column=1,columnspan=2,sticky=tk.EW,padx=5,pady=3)
        ff_combo.bind("<MouseWheel>", lambda event: "break") # Prevent main canvas scroll
        # Font Size
        ttk.Label(parent_frame, text="Default Font Size (pts):").grid(row=start_row+3,column=0,sticky=tk.W,padx=5,pady=3)
        font_size_var = tk.IntVar(value=self.settings.get(font_size_key, DEFAULT_FONT_SIZE))
        setattr(self, f"{font_size_key}_var", font_size_var)
        ttk.Spinbox(parent_frame, from_=6, to=24, textvariable=font_size_var, width=5).grid(row=start_row+3,column=1,sticky=tk.W,padx=5,pady=3)
        # Font Color
        ttk.Label(parent_frame, text="Default Font Color:").grid(row=start_row+4,column=0,sticky=tk.W,padx=5,pady=3)
        font_color_var = tk.StringVar(value=self.settings.get(font_color_key, DEFAULT_FONT_COLOR))
        setattr(self, f"{font_color_key}_var", font_color_var)
        ttk.Entry(parent_frame, textvariable=font_color_var, width=12).grid(row=start_row+4,column=1,sticky=tk.W,padx=5,pady=3)
        ttk.Button(parent_frame, text="Choose...", command=lambda v=font_color_var: self.choose_color_for_var(v)).grid(row=start_row+4,column=2,sticky=tk.W,padx=2,pady=3)

    def choose_color_for_var(self, color_var): # Helper for color choosers in settings
        initial_color = color_var.get()
        if not initial_color: # If empty, pick a default to show in chooser
            if "fill" in color_var._name: initial_color = DEFAULT_BOX_FILL_COLOR
            elif "outline" in color_var._name: initial_color = DEFAULT_BOX_OUTLINE_COLOR
            else: initial_color = DEFAULT_FONT_COLOR
        
        color_code = colorchooser.askcolor(initial_color, title="Choose color", parent=self)
        if color_code and color_code[1]: color_var.set(color_code[1])

    def choose_color_for_canvas(self, color_var): # Helper for color choosers in settings
        initial_color = color_var.get()
        if initial_color == "Default": initial_color = None
        if not initial_color: # If empty, pick a default to show in chooser
            if "fill" in color_var._name: initial_color = DEFAULT_BOX_FILL_COLOR
            elif "outline" in color_var._name: initial_color = DEFAULT_BOX_OUTLINE_COLOR
            else: initial_color = DEFAULT_FONT_COLOR
        
        color_code = colorchooser.askcolor(initial_color, title="Choose color", parent=self)
        if color_code and color_code[1]: color_var.set(color_code[1])
        
    def reset_canvas_color(self, button):
        button.set("Default")

    # --- Methods for managing custom lists ---
    def populate_conditional_rules_listbox(self):
        self.rules_listbox.delete(0, tk.END)
        for i, rule in enumerate(self.settings.get("conditional_formatting_rules", [])):
            desc = f"Rule {i+1}: Type='{rule['type']}'"
            if rule['type'] == 'group': desc += f", Group='{self.app.student_groups.get(rule.get('group_id'),{}).get('name','Unknown')}'"
            elif rule['type'] == 'behavior_count': desc += f", Behavior='{rule.get('behavior_name')}', Count>={rule.get('count_threshold')}, Hours={rule.get('time_window_hours')}"
            elif rule['type'] == 'quiz_score_threshold': desc += f", Quiz~'{rule.get('quiz_name_contains','')}', Score {rule.get('operator','<=')} {rule.get('score_threshold_percent','')}%"
            desc += f" -> Fill='{rule.get('color','')}', Outline='{rule.get('outline','')}'"
            self.rules_listbox.insert(tk.END, desc)
    def add_conditional_rule(self):
        dialog = ConditionalFormattingRuleDialog(self, self.app) # Pass app
        if dialog.result:
            if "conditional_formatting_rules" not in self.settings: self.settings["conditional_formatting_rules"] = []
            self.settings["conditional_formatting_rules"].append(dialog.result)
            self.settings_changed_flag = True
            self.populate_conditional_rules_listbox()
    def edit_selected_conditional_rule(self):
        selected_idx = self.rules_listbox.curselection()
        if not selected_idx: messagebox.showinfo("No Selection", "Please select a rule to edit.", parent=self); return
        idx_to_edit = selected_idx[0]
        rule_copy = self.settings["conditional_formatting_rules"][idx_to_edit].copy()
        dialog = ConditionalFormattingRuleDialog(self, self.app, rule_to_edit=rule_copy)
        if dialog.result:
            self.settings["conditional_formatting_rules"][idx_to_edit] = dialog.result
            self.settings_changed_flag = True
            self.populate_conditional_rules_listbox()
    def remove_selected_conditional_rule(self):
        selected_idx = self.rules_listbox.curselection()
        if not selected_idx: messagebox.showinfo("No Selection", "Please select a rule to remove.", parent=self); return
        if messagebox.askyesno("Confirm Remove", "Remove selected conditional formatting rule?", parent=self):
            del self.settings["conditional_formatting_rules"][selected_idx[0]]
            self.settings_changed_flag = True
            self.populate_conditional_rules_listbox()


    def _manage_custom_list_generic(self, listbox, custom_list_ref, item_type_name, add_func_name, edit_func_name):
        # This is a placeholder for a more generic dialog if needed, for now specific ones are used
        pass

    # Custom Behaviors (for Log Behavior dialog)
    def populate_custom_behaviors_listbox(self):
        self.custom_behaviors_listbox.delete(0, tk.END)
        for behavior_item in self.custom_behaviors_ref: # List of dicts or old strings
            name = behavior_item["name"] if isinstance(behavior_item, dict) else behavior_item
            self.custom_behaviors_listbox.insert(tk.END, name)
    def add_custom_behavior(self):
        if len(self.custom_behaviors_ref) >= MAX_CUSTOM_TYPES:
            messagebox.showwarning("Limit Reached", f"Maximum of {MAX_CUSTOM_TYPES} custom {item_type_name.lower()}s allowed.", parent=self); return
        name = simpledialog.askstring("Add Custom Behavior", "Enter name for the new behavior:", parent=self)
        if name and name.strip():
            name = name.strip()
            if any(cb_item == name or (isinstance(cb_item, dict) and cb_item.get("name") == name) for cb_item in self.custom_behaviors_ref):
                 messagebox.showwarning("Duplicate", f"Behavior '{name}' already exists.", parent=self); return
            self.custom_behaviors_ref.append({"name": name}) # Store as dict
            self.settings_changed_flag = True; self.app.save_custom_behaviors(); self.populate_custom_behaviors_listbox()
    def edit_selected_custom_behavior(self):
        sel_idx = self.custom_behaviors_listbox.curselection()
        if not sel_idx: messagebox.showinfo("No Selection", "Please select a behavior to edit.", parent=self); return
        idx = sel_idx[0]
        old_item = self.custom_behaviors_ref[idx]
        old_name = old_item["name"] if isinstance(old_item, dict) else old_item
        new_name = simpledialog.askstring("Edit Custom Behavior", "Enter new name:", initialvalue=old_name, parent=self)
        if new_name and new_name.strip():
            new_name = new_name.strip()
            if new_name != old_name and any(cb_item == new_name or (isinstance(cb_item, dict) and cb_item.get("name") == new_name and (idx != i if isinstance(cb_item,dict) else True) ) for i, cb_item in enumerate(self.custom_behaviors_ref)):
                 messagebox.showwarning("Duplicate", f"Behavior '{new_name}' already exists.", parent=self); return
            self.custom_behaviors_ref[idx] = {"name": new_name}
            self.settings_changed_flag = True; self.app.save_custom_behaviors(); self.populate_custom_behaviors_listbox()
    def remove_selected_custom_behavior(self):
        sel_idx = self.custom_behaviors_listbox.curselection()
        if not sel_idx: messagebox.showinfo("No Selection", "Please select a behavior to remove.", parent=self); return
        if messagebox.askyesno("Confirm Remove", "Remove selected custom behavior?", parent=self):
            del self.custom_behaviors_ref[sel_idx[0]]
            self.settings_changed_flag = True; self.app.save_custom_behaviors(); self.populate_custom_behaviors_listbox()
    
    def manage_behavior_initials(self):
        dialog = ManageInitialsDialog(self, self.settings["behavior_initial_overrides"], self.app.all_behaviors, "Behavior/Quiz")
        if dialog.initials_changed: self.settings_changed_flag = True
    def manage_homework_initials(self): # New
        dialog = ManageInitialsDialog(self, self.settings["homework_initial_overrides"], self.app.all_homework_statuses, "Homework Log")
        if dialog.initials_changed: self.settings_changed_flag = True
    def manage_quiz_mark_types(self):
        dialog = ManageMarkTypesDialog(self, self.settings["quiz_mark_types"], "Quiz Mark Types", DEFAULT_QUIZ_MARK_TYPES)
        if dialog.mark_types_changed: self.settings_changed_flag = True
    def manage_homework_mark_types(self): # New
        dialog = ManageMarkTypesDialog(self, self.settings["homework_mark_types"], "Homework Mark Types", DEFAULT_HOMEWORK_MARK_TYPES)
        if dialog.mark_types_changed: self.settings_changed_flag = True
    def manage_live_homework_select_options(self):
        dialog = ManageLiveSelectOptionsDialog(self, self.settings.get("live_homework_select_mode_options", DEFAULT_HOMEWORK_SESSION_BUTTONS.copy()))
        if dialog.options_changed_flag:
            self.settings["live_homework_select_mode_options"] = dialog.current_options
            self.settings_changed_flag = True

    
    
    def apply(self): # OK button of SettingsDialog
        # General Tab
        self.settings["autosave_interval_ms"] = self.autosave_interval_var.get() * 1000
        self.settings["grid_snap_enabled"] = self.grid_snap_var.get()
        self.settings["grid_size"] = self.grid_size_var.get()
        self.settings["student_groups_enabled"] = self.groups_enabled_var.get()
        self.settings["show_zoom_level_display"] = self.show_zoom_var.get()
        self.settings["max_undo_history_days"] = self.max_undo_days_var.get()
        self.settings["theme"] = self.theme.get()
        self.settings["canvas_color"] = self.custom_canvas_color.get()
        self.app.theme_style_using = self.theme2
        self.app.custom_canvas_color = self.custom_canvas_color.get()
        #print("Theme2", self.theme2)
        #print(self.theme.get(), "Get")
        # Student Display Tab
        self.settings["default_student_box_width"]=self.def_stud_w_var.get()
        self.settings["default_student_box_height"]=self.def_stud_h_var.get()
        self.settings["student_box_fill_color"]=self.student_box_fill_color_var.get()
        self.settings["student_box_outline_color"]=self.student_box_outline_color_var.get()
        self.settings["student_font_family"]=self.student_font_family_var.get()
        self.settings["student_font_size"]=self.student_font_size_var.get()
        self.settings["student_font_color"]=self.student_font_color_var.get()
        # Behavior/Quiz Log Tab
        self.settings["show_recent_incidents_on_boxes"] = self.show_recent_var.get()
        self.settings["num_recent_incidents_to_show"] = self.num_recent_var.get()
        self.settings["recent_incident_time_window_hours"] = self.time_window_var.get()
        self.settings["show_full_recent_incidents"] = self.show_full_recent_var.get()
        self.settings["reverse_incident_order"] = self.reverse_order_var.get()
        self.settings["default_quiz_name"] = self.def_quiz_name_var.get()
        self.settings["default_quiz_questions"] = self.def_quiz_q_var.get()
        self.settings["last_used_quiz_name_timeout_minutes"] = self.quiz_timeout_var.get()
        self.settings["show_recent_incidents_during_quiz"] = self.show_inc_quiz_var.get()
        # self.settings["combine_marks_for_display"] = self.combine_marks_display_var.get()
        # Homework Log Tab
        self.settings["show_recent_homeworks_on_boxes"] = self.show_recent_hw_var.get()
        self.settings["num_recent_homeworks_to_show"] = self.num_recent_hw_var.get()
        self.settings["recent_homework_time_window_hours"] = self.time_window_hw_var.get()
        self.settings["show_full_recent_homeworks"] = self.show_full_recent_hw_var.get()
        self.settings["reverse_homework_order"] = self.reverse_hw_order_var.get()
        self.settings["default_homework_name"] = self.def_hw_session_name_var.get()
        self.settings["live_homework_session_mode"] = self.live_hw_mode_var.get()
        self.settings["log_homework_marks_enabled"] = self.log_hw_marks_var.get()
        # Data & Export Tab
        self.settings["excel_export_separate_sheets_by_default"] = self.excel_sep_sheets_var.get()
        self.settings["excel_export_include_summaries_by_default"] = self.excel_inc_summary_var.get()
        self.settings["enable_excel_autosave"] = self.enable_excel_autosave_var.get()
        # Security Tab
        self.settings["password_on_open"] = self.pw_on_open_var.get()
        self.settings["password_on_edit_action"] = self.pw_on_edit_var.get()
        self.settings["password_auto_lock_enabled"] = self.pw_auto_lock_var.get()
        self.settings["password_auto_lock_timeout_minutes"] = self.pw_auto_lock_timeout_var.get()

        # Check if any significant setting actually changed by comparing with snapshot
        for key, initial_val in self.initial_settings_snapshot.items():
            current_val = self.settings.get(key)
            if isinstance(current_val, (list, dict)): # For mutable types, content comparison is needed
                if initial_val != current_val: # This might not catch all deep changes if not careful
                    self.settings_changed_flag = True; break
            elif initial_val != current_val:
                self.settings_changed_flag = True; break
        # If any custom list (behaviors, marks, etc.) was modified, their specific dialogs
        # would have set self.settings_changed_flag = True already.
        self.result = self.settings_changed_flag # Simpledialog will check this
"""

"""
# --- Command Pattern for Undo/Redo ---
class Command:
    def __init__(self, app, timestamp=None):
        self.app = app
        self.timestamp = timestamp or datetime.now().isoformat()

    def execute(self): raise NotImplementedError
    def undo(self): raise NotImplementedError
    def to_dict(self): return {'type': self.__class__.__name__, 'timestamp': self.timestamp, 'data': self._get_data_for_serialization()}
    def _get_data_for_serialization(self): raise NotImplementedError
    @classmethod
    def from_dict(cls, app, data_dict):
        command_type_name = data_dict['type']
        command_class = getattr(sys.modules[__name__], command_type_name, None)
        if command_class and issubclass(command_class, Command):
            try:
                return command_class._from_serializable_data(app, data_dict['data'], data_dict['timestamp'])
            except KeyError as e:
                print(f"Warning: Missing key '{e}' in data for command type '{command_type_name}'. Skipping command.")
                return None
        print(f"Warning: Unknown command type '{command_type_name}' in undo/redo history.")
        return None
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp): raise NotImplementedError

class MoveItemsCommand(Command):
    def __init__(self, app, items_moves, timestamp=None):
        super().__init__(app, timestamp)
        self.items_moves = items_moves # List of dicts: {'id', 'type', 'old_x', 'old_y', 'new_x', 'new_y'}

    def execute(self):
        for item_move in self.items_moves:
            item_id, item_type, new_x, new_y = item_move['id'], item_move['type'], item_move['new_x'], item_move['new_y']
            data_source = self.app.students if item_type == 'student' else self.app.furniture
            if item_id in data_source:
                data_source[item_id]['x'] = new_x
                data_source[item_id]['y'] = new_y
        self.app.update_status(f"Moved {len(self.items_moves)} item(s).")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def undo(self):
        for item_move in self.items_moves:
            item_id, item_type, old_x, old_y = item_move['id'], item_move['type'], item_move['old_x'], item_move['old_y']
            data_source = self.app.students if item_type == 'student' else self.app.furniture
            if item_id in data_source:
                data_source[item_id]['x'] = old_x
                data_source[item_id]['y'] = old_y
        self.app.update_status(f"Undid move of {len(self.items_moves)} item(s).")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def _get_data_for_serialization(self): return {'items_moves': self.items_moves}
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp): return cls(app, data['items_moves'], timestamp)

class AddItemCommand(Command):
    def __init__(self, app, item_id, item_type, item_data, old_next_id_num, timestamp=None):
        super().__init__(app, timestamp)
        self.item_id = item_id
        self.item_type = item_type
        self.item_data = item_data
        self.old_next_id_num = old_next_id_num

    def execute(self):
        data_source = self.app.students if self.item_type == 'student' else self.app.furniture
        data_source[self.item_id] = self.item_data.copy()
        if self.item_type == 'student':
            self.app.next_student_id_num = self.item_data.get('original_next_id_num_after_add', self.app.next_student_id_num)
            self.app.update_student_display_text(self.item_id)
            self.app.update_status(f"Student '{self.item_data['full_name']}' added.")
        else:
            self.app.next_furniture_id_num = self.item_data.get('original_next_id_num_after_add', self.app.next_furniture_id_num)
            self.app.update_status(f"Furniture '{self.item_data['name']}' added.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def undo(self):
        data_source = self.app.students if self.item_type == 'student' else self.app.furniture
        if self.item_id in data_source:
            item_name = data_source[self.item_id].get('full_name', data_source[self.item_id].get('name'))
            del data_source[self.item_id]
            self.app.canvas.delete(self.item_id)
            if self.item_type == 'student':
                self.app.next_student_id_num = self.old_next_id_num
                self.app.update_status(f"Undid add of student '{item_name}'.")
            else:
                self.app.next_furniture_id_num = self.old_next_id_num
                self.app.update_status(f"Undid add of furniture '{item_name}'.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def _get_data_for_serialization(self): return {'item_id': self.item_id, 'item_type': self.item_type, 'item_data': self.item_data, 'old_next_id_num': self.old_next_id_num}
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp): return cls(app, data['item_id'], data['item_type'], data['item_data'], data['old_next_id_num'], timestamp)

class DeleteItemCommand(Command):
    def __init__(self, app, item_id, item_type, item_data, associated_logs=None, timestamp=None):
        super().__init__(app, timestamp)
        self.item_id = item_id
        self.item_type = item_type
        self.item_data = item_data
        self.associated_logs = associated_logs or [] # For behavior and quiz logs
        self.associated_homework_logs = [] # New for homework logs

        if item_type == 'student': # Separate homework logs for students
            self.associated_homework_logs = [log.copy() for log in app.homework_log if log["student_id"] == item_id]


    def execute(self):
        data_source = self.app.students if self.item_type == 'student' else self.app.furniture
        item_name = "Item"
        if self.item_id in data_source:
            item_name = data_source[self.item_id].get('full_name', data_source[self.item_id].get('name'))
            del data_source[self.item_id]
        self.app.canvas.delete(self.item_id)
        if self.item_id in self.app.selected_items: self.app.selected_items.remove(self.item_id)

        if self.item_type == 'student':
            original_log_count = len(self.app.behavior_log)
            self.app.behavior_log = [log for log in self.app.behavior_log if log["student_id"] != self.item_id]
            logs_removed_count = original_log_count - len(self.app.behavior_log)

            original_homework_log_count = len(self.app.homework_log)
            self.app.homework_log = [log for log in self.app.homework_log if log["student_id"] != self.item_id]
            homework_logs_removed_count = original_homework_log_count - len(self.app.homework_log)

            self.app.update_status(f"Student '{item_name}', {logs_removed_count} behavior/quiz log(s), and {homework_logs_removed_count} homework log(s) deleted.")
        else:
            self.app.update_status(f"Furniture '{item_name}' deleted.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def undo(self):
        data_source = self.app.students if self.item_type == 'student' else self.app.furniture
        data_source[self.item_id] = self.item_data.copy()
        if self.item_type == 'student':
            self.app.update_student_display_text(self.item_id)
            for log_entry in self.associated_logs:
                if log_entry not in self.app.behavior_log: self.app.behavior_log.append(log_entry.copy())
            self.app.behavior_log.sort(key=lambda x: x.get("timestamp", ""))

            for hw_log_entry in self.associated_homework_logs: # Restore homework logs
                if hw_log_entry not in self.app.homework_log: self.app.homework_log.append(hw_log_entry.copy())
            self.app.homework_log.sort(key=lambda x: x.get("timestamp", ""))

            self.app.update_status(f"Undid delete of student '{self.item_data['full_name']}'. Logs restored.")
        else:
            self.app.update_status(f"Undid delete of furniture '{self.item_data['name']}'.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def _get_data_for_serialization(self):
        return {
            'item_id': self.item_id, 'item_type': self.item_type,
            'item_data': self.item_data, 'associated_logs': self.associated_logs,
            'associated_homework_logs': self.associated_homework_logs # Serialize homework logs
        }
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp):
        cmd = cls(app, data['item_id'], data['item_type'], data['item_data'], data.get('associated_logs'), timestamp)
        cmd.associated_homework_logs = data.get('associated_homework_logs', []) # Deserialize homework logs
        return cmd

class LogEntryCommand(Command): # For Behavior and Quiz logs
    def __init__(self, app, log_entry, student_id, timestamp=None):
        super().__init__(app, timestamp)
        self.log_entry = log_entry
        self.student_id = student_id

    def execute(self):
        # Behavior/Quiz logs go into self.app.behavior_log
        if not any(le == self.log_entry for le in self.app.behavior_log):
            self.app.behavior_log.append(self.log_entry.copy())
            self.app.behavior_log.sort(key=lambda x: x.get("timestamp", ""))
        self.app.update_student_display_text(self.student_id)
        log_type = self.log_entry.get("type", "behavior")
        behavior_name = self.log_entry.get("behavior", "Unknown")
        student_name = self.app.students.get(self.student_id, {}).get('full_name', 'Unknown Student')
        self.app.update_status(f"{log_type.capitalize()} '{behavior_name}' logged for {student_name}.")

    def undo(self):
        try:
            self.app.behavior_log.remove(self.log_entry)
        except ValueError:
            for i, entry in enumerate(self.app.behavior_log):
                if entry["timestamp"] == self.log_entry["timestamp"] and \
                   entry["student_id"] == self.log_entry["student_id"] and \
                   entry["behavior"] == self.log_entry["behavior"]:
                    del self.app.behavior_log[i]; break
        self.app.update_student_display_text(self.student_id)
        log_type = self.log_entry.get("type", "behavior")
        behavior_name = self.log_entry.get("behavior", "Unknown")
        student_name = self.app.students.get(self.student_id, {}).get('full_name', 'Unknown Student')
        self.app.update_status(f"Undid log of {log_type.capitalize()} '{behavior_name}' for {student_name}.")

    def _get_data_for_serialization(self): return {'log_entry': self.log_entry, 'student_id': self.student_id}
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp): return cls(app, data['log_entry'], data['student_id'], timestamp)

class LogHomeworkEntryCommand(Command): # New for Homework logs
    def __init__(self, app, log_entry, student_id, timestamp=None):
        super().__init__(app, timestamp)
        self.log_entry = log_entry
        self.student_id = student_id

    def execute(self):
        # Homework logs go into self.app.homework_log
        if not any(le == self.log_entry for le in self.app.homework_log):
            self.app.homework_log.append(self.log_entry.copy())
            self.app.homework_log.sort(key=lambda x: x.get("timestamp", ""))
        self.app.update_student_display_text(self.student_id) # Redraw student box
        homework_name = self.log_entry.get("homework_type", self.log_entry.get("behavior", "Unknown Homework")) # Use "homework_type" or "behavior"
        student_name = self.app.students.get(self.student_id, {}).get('full_name', 'Unknown Student')
        self.app.update_status(f"Homework '{homework_name}' logged for {student_name}.")

    def undo(self):
        try:
            self.app.homework_log.remove(self.log_entry)
        except ValueError:
            for i, entry in enumerate(self.app.homework_log):
                 # Match based on key fields for homework
                if entry["timestamp"] == self.log_entry["timestamp"] and \
                   entry["student_id"] == self.log_entry["student_id"] and \
                   entry.get("homework_type", entry.get("behavior")) == self.log_entry.get("homework_type", self.log_entry.get("behavior")):
                    del self.app.homework_log[i]; break
        self.app.update_student_display_text(self.student_id)
        homework_name = self.log_entry.get("homework_type", self.log_entry.get("behavior", "Unknown Homework"))
        student_name = self.app.students.get(self.student_id, {}).get('full_name', 'Unknown Student')
        self.app.update_status(f"Undid log of homework '{homework_name}' for {student_name}.")

    def _get_data_for_serialization(self): return {'log_entry': self.log_entry, 'student_id': self.student_id}
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp): return cls(app, data['log_entry'], data['student_id'], timestamp)


class EditItemCommand(Command):
    def __init__(self, app, item_id, item_type, old_item_data, new_item_data_changes, timestamp=None):
        super().__init__(app, timestamp)
        self.item_id = item_id
        self.item_type = item_type
        self.old_item_data_snapshot = old_item_data
        self.new_item_data_changes = new_item_data_changes

    def execute(self):
        data_source = self.app.students if self.item_type == 'student' else self.app.furniture
        if self.item_id in data_source:
            data_source[self.item_id].update(self.new_item_data_changes)
            if self.item_type == 'student':
                self.app.update_student_display_text(self.item_id)
                self.app.update_status(f"Student '{data_source[self.item_id]['full_name']}' edited.")
            else:
                self.app.update_status(f"Furniture '{data_source[self.item_id]['name']}' edited.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def undo(self):
        data_source = self.app.students if self.item_type == 'student' else self.app.furniture
        if self.item_id in data_source:
            data_source[self.item_id] = self.old_item_data_snapshot.copy()
            if self.item_type == 'student':
                self.app.update_student_display_text(self.item_id)
                self.app.update_status(f"Undid edit for student '{data_source[self.item_id]['full_name']}'.")
            else:
                self.app.update_status(f"Undid edit for furniture '{data_source[self.item_id]['name']}'.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def _get_data_for_serialization(self):
        return {
            'item_id': self.item_id, 'item_type': self.item_type,
            'old_item_data_snapshot': self.old_item_data_snapshot,
            'new_item_data_changes': self.new_item_data_changes
        }
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp):
        return cls(app, data['item_id'], data['item_type'],
                   data['old_item_data_snapshot'], data['new_item_data_changes'], timestamp)

class ChangeItemsSizeCommand(Command):
    def __init__(self, app, items_sizes_changes, timestamp=None):
        super().__init__(app, timestamp)
        self.items_sizes_changes = items_sizes_changes

    def _apply_sizes(self, use_new_sizes):
        changed_item_names = []
        for item_size_info in self.items_sizes_changes:
            item_id, item_type = item_size_info['id'], item_size_info['type']
            w = item_size_info['new_w'] if use_new_sizes else item_size_info['old_w']
            h = item_size_info['new_h'] if use_new_sizes else item_size_info['old_h']
            data_source = self.app.students if item_type == 'student' else self.app.furniture
            if item_id in data_source:
                if item_type == 'student':
                    if 'style_overrides' not in data_source[item_id]: data_source[item_id]['style_overrides'] = {}
                    data_source[item_id]['style_overrides']['width'] = w
                    data_source[item_id]['style_overrides']['height'] = h
                    data_source[item_id]['width'] = w # Keep base in sync
                    data_source[item_id]['height'] = h
                else:
                    data_source[item_id]['width'] = w
                    data_source[item_id]['height'] = h
                changed_item_names.append(data_source[item_id].get('full_name', data_source[item_id].get('name', item_id)))
        return changed_item_names

    def execute(self):
        names = self._apply_sizes(use_new_sizes=True)
        self.app.update_status(f"Size changed for {len(names)} item(s): {', '.join(names[:3])}{'...' if len(names)>3 else ''}.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def undo(self):
        names = self._apply_sizes(use_new_sizes=False)
        self.app.update_status(f"Undid size change for {len(names)} item(s): {', '.join(names[:3])}{'...' if len(names)>3 else ''}.")
        self.app.draw_all_items(check_collisions_on_redraw=True)

    def _get_data_for_serialization(self): return {'items_sizes_changes': self.items_sizes_changes}
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp): return cls(app, data['items_sizes_changes'], timestamp)

class MarkLiveQuizQuestionCommand(Command):
    def __init__(self, app, student_id, action_taken, timestamp=None):
        super().__init__(app, timestamp)
        self.student_id = student_id
        self.action_taken = action_taken
        self.previous_student_score_state = None

    def execute(self):
        if self.previous_student_score_state is None:
            self.previous_student_score_state = self.app.live_quiz_scores.get(self.student_id, {"correct": 0, "total_asked": 0}).copy()
        current_score = self.app.live_quiz_scores.get(self.student_id, {"correct": 0, "total_asked": 0}).copy()
        current_score["total_asked"] += 1
        if self.action_taken == "correct": current_score["correct"] += 1
        self.app.live_quiz_scores[self.student_id] = current_score
        self.app.draw_single_student(self.student_id)
        student_name = self.app.students[self.student_id]['full_name']
        self.app.update_status(f"Live Quiz: '{self.action_taken.capitalize()}' for {student_name}. Score: {current_score['correct']}/{current_score['total_asked']}")

    def undo(self):
        if self.previous_student_score_state is not None:
            self.app.live_quiz_scores[self.student_id] = self.previous_student_score_state.copy()
            if self.app.live_quiz_scores[self.student_id]["total_asked"] == 0 and self.app.live_quiz_scores[self.student_id]["correct"] == 0:
                del self.app.live_quiz_scores[self.student_id]
        elif self.student_id in self.app.live_quiz_scores:
            current_score = self.app.live_quiz_scores[self.student_id]
            current_score["total_asked"] -= 1
            if self.action_taken == "correct": current_score["correct"] -= 1
            if current_score["total_asked"] <= 0: del self.app.live_quiz_scores[self.student_id]
        self.app.draw_single_student(self.student_id)
        student_name = self.app.students[self.student_id]['full_name']
        score_info = self.app.live_quiz_scores.get(self.student_id)
        status = f"Undo Live Quiz Mark for {student_name}. Score: {score_info['correct']}/{score_info['total_asked']}" if score_info else f"Undo Live Quiz Mark for {student_name}. No questions marked."
        self.app.update_status(status)

    def _get_data_for_serialization(self):
        return {'student_id': self.student_id, 'action_taken': self.action_taken, 'previous_student_score_state': self.previous_student_score_state}
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp):
        cmd = cls(app, data['student_id'], data['action_taken'], timestamp)
        cmd.previous_student_score_state = data.get('previous_student_score_state')
        return cmd

class MarkLiveHomeworkCommand(Command): # New for Live Homework
    def __init__(self, app, student_id, homework_actions, session_mode, timestamp=None):
        super().__init__(app, timestamp)
        self.student_id = student_id
        self.homework_actions = homework_actions # Dict: {"homework_type_name": "yes/no/selected_option"} or list of selected options
        self.session_mode = session_mode # "Yes/No" or "Select"
        self.previous_homework_state = None # To store previous state for undo

    def execute(self):
        if self.previous_homework_state is None:
            self.previous_homework_state = self.app.live_homework_scores.get(self.student_id, {}).copy()

        # Update live_homework_scores based on homework_actions and session_mode
        # For "Yes/No", homework_actions might be {"Reading": "yes", "Math": "no"}
        # For "Select", homework_actions might be ["Done", "Signed"]
        current_hw_data = self.app.live_homework_scores.get(self.student_id, {}).copy()
        if self.session_mode == "Yes/No":
            current_hw_data.update(self.homework_actions) # Overwrite/add specific yes/no statuses
        elif self.session_mode == "Select":
            # Store as a list of selected actions for this student for this session
            current_hw_data["selected_options"] = list(self.homework_actions) # Ensure it's a list

        self.app.live_homework_scores[self.student_id] = current_hw_data
        self.app.draw_single_student(self.student_id) # Redraw to update display
        student_name = self.app.students[self.student_id]['full_name']
        self.app.update_status(f"Live Homework updated for {student_name}.")

    def undo(self):
        if self.previous_homework_state is not None:
            self.app.live_homework_scores[self.student_id] = self.previous_homework_state.copy()
            if not self.app.live_homework_scores[self.student_id]: # If restored to empty
                del self.app.live_homework_scores[self.student_id]
        elif self.student_id in self.app.live_homework_scores: # Should not happen if previous_homework_state was set
            del self.app.live_homework_scores[self.student_id]

        self.app.draw_single_student(self.student_id)
        student_name = self.app.students[self.student_id]['full_name']
        self.app.update_status(f"Undo Live Homework update for {student_name}.")

    def _get_data_for_serialization(self):
        return {
            'student_id': self.student_id,
            'homework_actions': self.homework_actions,
            'session_mode': self.session_mode,
            'previous_homework_state': self.previous_homework_state
        }
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp):
        cmd = cls(app, data['student_id'], data['homework_actions'], data['session_mode'], timestamp)
        cmd.previous_homework_state = data.get('previous_homework_state')
        return cmd


class ChangeStudentStyleCommand(Command):
    def __init__(self, app, student_id, style_property, old_value, new_value, timestamp=None):
        super().__init__(app, timestamp)
        self.student_id = student_id
        self.style_property = style_property
        self.old_value = old_value
        self.new_value = new_value

    def execute(self):
        student = self.app.students.get(self.student_id)
        if student:
            if "style_overrides" not in student: student["style_overrides"] = {}
            if self.new_value is None:
                if self.style_property in student["style_overrides"]: del student["style_overrides"][self.style_property]
            else: student["style_overrides"][self.style_property] = self.new_value
            self.app.update_student_display_text(self.student_id)
            self.app.draw_single_student(self.student_id, check_collisions=True)
            self.app.update_status(f"Style '{self.style_property}' updated for {student['full_name']}.")

    def undo(self):
        student = self.app.students.get(self.student_id)
        if student:
            if "style_overrides" not in student: student["style_overrides"] = {}
            if self.old_value is None:
                if self.style_property in student["style_overrides"]: del student["style_overrides"][self.style_property]
            else: student["style_overrides"][self.style_property] = self.old_value
            if not student["style_overrides"]: del student["style_overrides"]
            self.app.update_student_display_text(self.student_id)
            self.app.draw_single_student(self.student_id, check_collisions=True)
            self.app.update_status(f"Undid style '{self.style_property}' change for {student['full_name']}.")

    def _get_data_for_serialization(self):
        return {'student_id': self.student_id, 'style_property': self.style_property, 'old_value': self.old_value, 'new_value': self.new_value}
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp):
        return cls(app, data['student_id'], data['style_property'], data['old_value'], data['new_value'], timestamp)

class ManageStudentGroupCommand(Command):
    def __init__(self, app, old_groups_snapshot, new_groups_snapshot,
                 old_student_group_assignments, new_student_group_assignments,
                 old_next_group_id_num, new_next_group_id_num, timestamp=None):
        super().__init__(app, timestamp)
        self.old_groups_snapshot = old_groups_snapshot
        self.new_groups_snapshot = new_groups_snapshot
        self.old_student_group_assignments = old_student_group_assignments
        self.new_student_group_assignments = new_student_group_assignments
        self.old_next_group_id_num = old_next_group_id_num
        self.new_next_group_id_num = new_next_group_id_num

    def execute(self):
        self.app.student_groups = self.new_groups_snapshot.copy()
        for student_id, group_id in self.new_student_group_assignments.items():
            if student_id in self.app.students: self.app.students[student_id]['group_id'] = group_id
        for student_id in self.app.students:
            if student_id not in self.new_student_group_assignments and 'group_id' in self.app.students[student_id]:
                del self.app.students[student_id]['group_id']
        self.app.next_group_id_num = self.new_next_group_id_num
        self.app.settings["next_group_id_num"] = self.new_next_group_id_num
        self.app.save_student_groups()
        self.app.draw_all_items(check_collisions_on_redraw=True)
        self.app.update_status("Student groups updated.")

    def undo(self):
        self.app.student_groups = self.old_groups_snapshot.copy()
        for student_id, group_id in self.old_student_group_assignments.items():
            if student_id in self.app.students: self.app.students[student_id]['group_id'] = group_id
        for student_id in self.app.students:
            if student_id not in self.old_student_group_assignments and 'group_id' in self.app.students[student_id]:
                del self.app.students[student_id]['group_id']
        self.app.next_group_id_num = self.old_next_group_id_num
        self.app.settings["next_group_id_num"] = self.old_next_group_id_num
        self.app.save_student_groups()
        self.app.draw_all_items(check_collisions_on_redraw=True)
        self.app.update_status("Student group update undone.")

    def _get_data_for_serialization(self):
        return {
            'old_groups_snapshot': self.old_groups_snapshot, 'new_groups_snapshot': self.new_groups_snapshot,
            'old_student_group_assignments': self.old_student_group_assignments, 'new_student_group_assignments': self.new_student_group_assignments,
            'old_next_group_id_num': self.old_next_group_id_num, 'new_next_group_id_num': self.new_next_group_id_num,
        }
    @classmethod
    def _from_serializable_data(cls, app, data, timestamp):
        return cls(app, data['old_groups_snapshot'], data['new_groups_snapshot'],
                   data['old_student_group_assignments'], data['new_student_group_assignments'],
                   data['old_next_group_id_num'], data['new_next_group_id_num'], timestamp)
"""



# --- Dialog Classes ---
class PasswordPromptDialog(simpledialog.Dialog):
    def __init__(self, parent, title, prompt, password_manager_instance):
        self.prompt = prompt
        self.password_manager = password_manager_instance
        self.result = False # True if password correct or not set, False otherwise
        super().__init__(parent, title)

    def body(self, master):
        ttk.Label(master, text=self.prompt, wraplength=280).pack(pady=5)
        self.password_entry = ttk.Entry(master, show="*", width=30)
        self.password_entry.pack(pady=5)
        self.status_label = ttk.Label(master, text="", foreground="red")
        self.status_label.pack(pady=2)
        return self.password_entry # initial focus

    def buttons(self):
        box = ttk.Frame(self)
        ttk.Button(box, text="OK", width=10, command=self.ok, default=tk.ACTIVE).pack(side=tk.LEFT, padx=5, pady=5)
        ttk.Button(box, text="Cancel", width=10, command=self.cancel).pack(side=tk.LEFT, padx=5, pady=5)
        self.bind("<Return>", lambda e: self.ok())
        self.bind("<Escape>", lambda e: self.cancel())
        box.pack()

    def apply(self):
        password_attempt = self.password_entry.get()
        if self.password_manager.unlock_application(password_attempt): # unlock_application handles recovery pw too
            self.result = True
        else:
            self.status_label.config(text="Incorrect password.")
            self.password_entry.focus_set()
            self.password_entry.select_range(0, tk.END)
            self.result = False # Explicitly set to false, stay open
            # To prevent dialog from closing on incorrect password, we don't call super().ok() or cancel
            # Instead, the dialog stays open. The caller of this dialog will check self.result.
            # This means the typical simpledialog auto-close on OK needs to be managed carefully.
            # For this use case, we want it to close only on success or cancel.
            # The `ok` method will be called. If result is False, the dialog won't close.
            # We need to ensure `ok` can prevent closing.
            # A simple way is to override `ok` more directly or ensure `validate` fails.
            # simpledialog.Dialog closes if validate() returns true.

    def ok(self, event=None): # Override ok to control closing
        if not self.validate(): # validate calls apply
            self.password_entry.focus_set()
            return # Don't close if validation (password check) fails
        self.withdraw()
        self.update_idletasks()
        # apply has already been called by validate
        self.parent.focus_set() # Give focus back to parent
        self.destroy()


    def validate(self): # This is called by simpledialog's ok method
        self.apply() # Calls our apply which sets self.result
        return self.result # If True, dialog closes. If False, stays open due to logic in apply.

class AddEditStudentDialog(simpledialog.Dialog):
    # ... (similar to v51, but needs group dropdown to be populated from app.student_groups)
    def __init__(self, parent, title, student_data=None, app=None):
        self.student_data = student_data
        self.app = app # To access student_groups
        self.result = None
        super().__init__(parent, title)

    def body(self, master):
        ttk.Label(master, text="First Name:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.fn_var = tk.StringVar(value=self.student_data["first_name"] if self.student_data else "")
        self.fn_entry = ttk.Entry(master, textvariable=self.fn_var, width=30); self.fn_entry.grid(row=0, column=1, padx=5, pady=2)

        ttk.Label(master, text="Last Name:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        self.ln_var = tk.StringVar(value=self.student_data["last_name"] if self.student_data else "")
        self.ln_entry = ttk.Entry(master, textvariable=self.ln_var, width=30); self.ln_entry.grid(row=1, column=1, padx=5, pady=2)

        ttk.Label(master, text="Nickname (Optional):").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)
        self.nick_var = tk.StringVar(value=self.student_data.get("nickname", "") if self.student_data else "")
        self.nick_entry = ttk.Entry(master, textvariable=self.nick_var, width=30); self.nick_entry.grid(row=2, column=1, padx=5, pady=2)

        ttk.Label(master, text="Gender:").grid(row=3, column=0, sticky=tk.W, padx=5, pady=2)
        self.gender_var = tk.StringVar(value=self.student_data.get("gender", "Boy") if self.student_data else "Boy")
        gender_frame = ttk.Frame(master)
        ttk.Radiobutton(gender_frame, text="Boy", variable=self.gender_var, value="Boy").pack(side=tk.LEFT)
        ttk.Radiobutton(gender_frame, text="Girl", variable=self.gender_var, value="Girl").pack(side=tk.LEFT, padx=5)
        ttk.Radiobutton(gender_frame, text="Other", variable=self.gender_var, value="Other").pack(side=tk.LEFT)
        gender_frame.grid(row=3, column=1, sticky=tk.W, padx=5, pady=2)

        if self.app and self.app.settings.get("student_groups_enabled", True):
            ttk.Label(master, text="Group:").grid(row=4, column=0, sticky=tk.W, padx=5, pady=2)
            self.group_var = tk.StringVar()
            group_options = {"NONE_GROUP_SENTINEL": "No Group"} # Sentinel for no group
            for gid, gdata in sorted(self.app.student_groups.items(), key=lambda item: item[1]['name']):
                group_options[gid] = gdata['name']
            
            self.group_combobox = ttk.Combobox(master, textvariable=self.group_var, values=list(group_options.values()), state="readonly", width=28)
            self.group_combobox_map = {name: gid for gid, name in group_options.items()} # Map display name back to ID
            
            current_group_id = self.student_data.get("group_id") if self.student_data else None
            if current_group_id and current_group_id in self.app.student_groups:
                self.group_var.set(self.app.student_groups[current_group_id]['name'])
            else:
                self.group_var.set("No Group")
            self.group_combobox.grid(row=4, column=1, padx=5, pady=2, sticky=tk.W)
            self.group_combobox.bind("<MouseWheel>", lambda event: "break") # Prevent main canvas scroll

        return self.fn_entry

    def apply(self):
        first_name = self.fn_var.get().strip()
        last_name = self.ln_var.get().strip()
        nickname = self.nick_var.get().strip()
        gender = self.gender_var.get()
        group_id_selection = None
        if self.app and self.app.settings.get("student_groups_enabled", True) and hasattr(self, 'group_var'):
            selected_group_name = self.group_var.get()
            group_id_selection = self.group_combobox_map.get(selected_group_name)
            if group_id_selection == "NONE_GROUP_SENTINEL": group_id_selection = None

        if first_name and last_name:
            self.result = (first_name, last_name, nickname, gender, group_id_selection)
        else:
            messagebox.showwarning("Missing Information", "First Name and Last Name are required.", parent=self)
            self.result = None # Stay open

class AddFurnitureDialog(simpledialog.Dialog):
    # ... (same as v51)
    def __init__(self, parent, title, furniture_data=None):
        self.furniture_data = furniture_data
        self.result = None
        super().__init__(parent, title)
    def body(self, master):
        ttk.Label(master, text="Name:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.name_var = tk.StringVar(value=self.furniture_data["name"] if self.furniture_data else "Desk")
        self.name_entry = ttk.Entry(master, textvariable=self.name_var); self.name_entry.grid(row=0, column=1, padx=5, pady=2)
        ttk.Label(master, text="Type:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        self.type_var = tk.StringVar(value=self.furniture_data["type"] if self.furniture_data else "Rebbi's Desk")
        self.type_entry = ttk.Entry(master, textvariable=self.type_var); self.type_entry.grid(row=1, column=1, padx=5, pady=2)
        ttk.Label(master, text="Width:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=2)
        self.width_var = tk.IntVar(value=self.furniture_data["width"] if self.furniture_data else REBBI_DESK_WIDTH)
        self.width_spinbox = ttk.Spinbox(master, from_=20, to=1000, textvariable=self.width_var, width=5); self.width_spinbox.grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)
        ttk.Label(master, text="Height:").grid(row=3, column=0, sticky=tk.W, padx=5, pady=2)
        self.height_var = tk.IntVar(value=self.furniture_data["height"] if self.furniture_data else REBBI_DESK_HEIGHT)
        self.height_spinbox = ttk.Spinbox(master, from_=20, to=1000, textvariable=self.height_var, width=5); self.height_spinbox.grid(row=3, column=1, sticky=tk.W, padx=5, pady=2)
        return self.name_entry
    def apply(self):
        name = self.name_var.get().strip(); item_type = self.type_var.get().strip()
        width = self.width_var.get(); height = self.height_var.get()
        if name and item_type and width > 0 and height > 0: self.result = (name, item_type, width, height)
        else: messagebox.showwarning("Invalid Input", "Name, Type, Width, and Height are required and must be positive.", parent=self); self.result = None

class BehaviorDialog(simpledialog.Dialog):
    # ... (same as v51)
    def __init__(self, parent, title, all_behaviors, custom_behaviors):
        self.all_behaviors = all_behaviors
        self.custom_behaviors = custom_behaviors # For potential editing in future, not used now
        self.result = None
        self.selected_behavior_var = tk.StringVar()
        super().__init__(parent, title)
    def body(self, master):
        
        master.grid_columnconfigure(0, weight=1) # Allow master frame to expand
        top_label = ttk.Label(master, text="Select Behavior:")
        top_label.grid(row=0, column=0, columnspan=6, sticky="nw", pady=2, padx=5)

        # Frame for buttons with scrollbar
        button_frame_outer = ttk.Frame(master)
        button_frame_outer.grid(row=1, column=0, columnspan=6, sticky="nsew", pady=(5,10), )
        master.grid_rowconfigure(1, weight=1) # Allow button area to expand

        theheight=0
        for i in range(0,len(self.all_behaviors),6): theheight += 115
        
        btn_canvas = tk.Canvas(button_frame_outer, borderwidth=0,width=1000,height= theheight)
        btn_scrollbar = ttk.Scrollbar(button_frame_outer, orient="vertical", command=btn_canvas.yview)
        scrollable_frame_for_buttons = ttk.Frame(btn_canvas)

        scrollable_frame_for_buttons.bind("<Configure>", lambda e: btn_canvas.configure(scrollregion=btn_canvas.bbox("all")))
        btn_canvas.create_window((0, 0), window=scrollable_frame_for_buttons, anchor="nw")
        btn_canvas.configure(yscrollcommand=btn_scrollbar.set)

        btn_canvas.pack(side="left", fill="both", expand=True)
        btn_scrollbar.pack(side="right", fill="y")

        # Populate buttons
        row_idx, col_idx = 0, 0
        max_cols = 6 # Adjust number of columns as desired
        button_width_chars = 14 # Approximate characters
        button_height_lines = 5 # Approximate lines
        button_width = 17
        button_height = 5
        wraplength=button_width_chars*7
        button_font = ('TkDefaultFont', 15)
        b = ttk.Style(); b.configure("Keypad.TButton", font=button_font, wraplength=button_width_chars*10,justify='center',padding=(0))
        for i, behavior_text in enumerate(self.all_behaviors):
            btn = ttk.Button(scrollable_frame_for_buttons, text=behavior_text,
                            padding=(0,19),# Rough estimate for pixel width
                            width=button_width_chars, style="Keypad.TButton",
                            command=lambda n=behavior_text: self.behavior_selected(n))
            btn.grid(row=row_idx, column=col_idx, sticky="nsew", padx=2, pady=3)
            scrollable_frame_for_buttons.grid_columnconfigure(col_idx, weight=1) # Allow columns to expand
            col_idx += 1
            if col_idx >= max_cols:
                col_idx = 0
                row_idx += 1
        if col_idx != 0: # Ensure last row also configures row weight if partially filled
             scrollable_frame_for_buttons.grid_rowconfigure(row_idx, weight=1)
        

        comment_label = ttk.Label(master, text="Additional Comment (Optional):")
        comment_label.grid(row=2,column=0,columnspan=6, sticky="sw", pady=(8,2), padx=5)
        self.comment_text_widget = tk.Text(master, width=50, height=4, wrap=tk.WORD)
        self.comment_text_widget.grid(row=3, column=0,columnspan=6, pady=(0,5), padx=5, sticky="sew")
        master.grid_rowconfigure(3, weight=0) # Comment text doesn't expand as much

        # Set initial focus if desired, e.g., to the first button or comment box
        # For now, default Tk focus handling.
        return self.comment_text_widget # Or another widget for initial focus


        """        
        
        ttk.Label(master, text="Select Behavior:").pack(pady=5)
        self.behavior_var = tk.StringVar()
        self.behavior_combobox = ttk.Combobox(master, textvariable=self.behavior_var, values=self.all_behaviors, width=30)
        if self.all_behaviors: self.behavior_combobox.set(self.all_behaviors[0])
        self.behavior_combobox.pack(pady=5)
        self.behavior_combobox.bind("<MouseWheel>", lambda event: "break")
        ttk.Label(master, text="Comment (Optional):").pack(pady=5)
        self.comment_entry = ttk.Entry(master, width=33); self.comment_entry.pack(pady=5)
        return self.behavior_combobox
        """
    
    
    
    def behavior_selected(self, behavior_name):
        self.selected_behavior_var.set(behavior_name)
        self.ok() # Trigger apply and close

    def buttonbox(self): # Standard OK/Cancel are usually handled by simpledialog.Dialog
        # We only need a cancel button as OK is triggered by behavior selection
        cancel_button_frame = ttk.Frame(self)
        cancel_button_frame.pack(fill=tk.X, padx=5, pady=(0,5)) # Pad bottom
        ttk.Button(cancel_button_frame, text="Cancel", width=10, command=self.cancel).pack(side=tk.RIGHT, padx=5)
        self.bind("<Escape>", self.cancel)

    def apply(self):
        behavior = self.selected_behavior_var.get()
        comment = self.comment_text_widget.get("1.0", tk.END).strip()
        if not behavior: # Should not happen if ok() is only called on selection
            messagebox.showwarning("Input Error", "Please select a behavior.", parent=self)
            self.result = None
            return
        self.result = (behavior, comment)
    
    
    #def apply(self):
    #    behavior = self.behavior_var.get().strip(); comment = self.comment_entry.get().strip()
    #    if behavior: self.result = (behavior, comment)
    #    else: messagebox.showwarning("Input Required", "Please select or enter a behavior.", parent=self); self.result = None

class ManualHomeworkLogDialog(simpledialog.Dialog):
    def __init__(self, parent, title, all_homework_types, custom_homework_types, log_marks_enabled, homework_mark_types, homework_templates, app):
        self.all_homework_types = all_homework_types # List of strings (for the combobox)
        self.custom_homework_types = custom_homework_types
        self.log_marks_enabled = log_marks_enabled
        self.homework_mark_types = homework_mark_types
        self.homework_templates = homework_templates
        self.app = app # Pass app instance
        self.result = None
        self.mark_entry_vars = {}
        super().__init__(parent, title)

    def body(self, master):
        main_frame = ttk.Frame(master); main_frame.pack(fill=tk.BOTH, side=tk.LEFT, expand=True, padx=10, pady=10)

        # Homework Type / Template Selection
        type_frame = ttk.LabelFrame(main_frame, text="Homework Assignment"); type_frame.pack(pady=5, fill=tk.X)
        ttk.Label(type_frame, text="Name/Type:").pack(side=tk.TOP, padx=5, anchor='w')
        self.homework_type_var = tk.StringVar()
        
        # MODIFICATION: Populate combobox with homework types and template names
        combined_options = sorted(list(set(self.all_homework_types + [tpl['name'] for tpl_id, tpl in self.homework_templates.items()])))
        
        self.homework_type_combobox = ttk.Combobox(type_frame, textvariable=self.homework_type_var, values=combined_options, width=40)
        self.homework_type_combobox.pack(side=tk.LEFT, padx=5, pady=(0,5), fill=tk.X, expand=True)
        if combined_options: self.homework_type_combobox.set(combined_options[0])
        self.homework_type_combobox.bind("<<ComboboxSelected>>", self.on_template_select)
        self.homework_type_combobox.bind("<MouseWheel>", lambda event: "break")

        # Number of Items
        self.num_items_frame = ttk.Frame(main_frame)
        self.num_items_frame.pack(pady=5, fill=tk.X)
        ttk.Label(self.num_items_frame, text="Number of Items/Questions:").pack(side=tk.LEFT, padx=5)
        self.num_items_var = tk.StringVar(value="10")
        self.num_items_spinbox = ttk.Spinbox(self.num_items_frame, from_=1, to=200, textvariable=self.num_items_var, width=5)
        self.num_items_spinbox.pack(side=tk.LEFT, padx=5)

        # Marks Frame
        self.marks_widgets_frame = ttk.LabelFrame(main_frame, text="Marks Details")
        self.marks_widgets_frame.pack(pady=10, padx=5, fill=tk.BOTH, expand=True)
        

        # Marks Frame (if enabled)
        self.marks_widgets_frame = ttk.LabelFrame(main_frame, text="Marks Details") # Packed later
        if self.log_marks_enabled and self.homework_mark_types:
            
            self.homework_type_combobox = ttk.Combobox(type_frame, textvariable=self.homework_type_var, values=combined_options, width=30, state="readonly")
            
            
            if combined_options: self.homework_type_combobox.set(combined_options[0])
            self.homework_type_combobox.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
            
            self.homework_type_combobox.bind("<<ComboboxSelected>>", self.on_template_select)
            self.num_items_frame.pack(pady=5, fill=tk.X)
            self.marks_widgets_frame.pack(pady=10, padx=5, fill=tk.BOTH, expand=True)
            self.target_entry2 = []
            self.target_entry3 = []
            self.cte = -1
            cols = 2 # Two columns for marks
            current_col = 0; current_row_marks = 0
            for i, mark_type in enumerate(self.homework_mark_types):
                mark_id = mark_type["id"]; mark_name = mark_type["name"]
                ttk.Label(self.marks_widgets_frame, text=f"{mark_name}:").grid(row=current_row_marks, column=current_col*2, sticky=tk.W, padx=5, pady=3)
                var = tk.StringVar()
                # Try to set default value from mark_type if it makes sense (e.g., for non-point entries or typical scores)
                # For point-based ones, usually user input is expected.
                if "default_value" in mark_type : var.set(str(mark_type["default_value"]))

                entry = ttk.Entry(self.marks_widgets_frame, textvariable=var, width=8)
                entry.grid(row=current_row_marks, column=current_col*2 + 1, sticky=tk.EW, padx=5, pady=3)
                self.mark_entry_vars[mark_id] = var
                entry.bind("<FocusIn>", lambda x=i,x2=i: self.set_numpad(x,x2))
                self.target_entry2.append(var)
                self.target_entry3.append(mark_type["name"])
                self.cte = i
                self.tte = i
                current_col += 1
                if current_col >= cols: current_col = 0; current_row_marks +=1
            #print(main_frame.slaves)
            self.keypad_frame = ttk.Frame(master, relief='sunken',borderwidth=10)
            self.keypad_frame.pack(side=tk.RIGHT)
            self.keypad_frame.grid_propagate(True)
            self.allow_decimal = True
            self.mark_vars2 = {} # {mark_type_id: tk.StringVar()}
            for mt in self.mark_vars2:
                self.mark_vars2[mt["id"]] = tk.StringVar()
            
            for i, mt_config in enumerate(self.mark_vars2):
                label_text = mt_config["name"]
                if mt_config.get("is_extra_credit"): label_text += " (Bonus)"
            #print(self.mark_vars2)
            self.target_entry = self.mark_entry_vars[mark_type["id"]]
            self.target_entry_name = mark_type["name"]
            
            self.target_name_label = ttk.Label(self.keypad_frame,text=self.target_entry_name)
            self.target_name_label.grid(column=0,row=0,columnspan=9)
            
            buttons = [('7',1,0),('8',1,1),('9',1,2),('4',2,0),('5',2,1),('6',2,2),('1',3,0),('2',3,1),('3',3,2),('0',4,0),('.',4,1) if self.allow_decimal else (' ',4,1),('⌫',4,2),('/',2,3)]
            button_font = ('TkDefaultFont', 15)
            self._next_entry()
            for i in range(4): self.rowconfigure(i, minsize=2000,weight=1)
            for i in range(4): self.columnconfigure(i, weight=1)
            for (text, r, c) in buttons:
                if text == ' ': continue
                action = lambda x=text: self._on_press(x)
                ttk.Button(self.keypad_frame, text=text, command=action, style="Keypad.TButton",padding=17,width=5).grid(row=r, column=c, padx=1, pady=1, sticky="nsew")
            ttk.Button(self.keypad_frame, text="Clear", command=self._clear_entry, style="Keypad.TButton").grid(row=1, column=3, padx=1, pady=1, sticky="nsew")
            ttk.Button(self.keypad_frame, text='Next', command=self._next_entry, style="Keypad.TButton").grid(row=4,column=3,padx=1,pady=1,sticky='nsew')
            ttk.Button(self.keypad_frame, text='Previous', command=self._previous_entry, style="Keypad.TButton").grid(row=3,column=3,padx=1,pady=1,sticky='nsew')
            s = ttk.Style(); s.configure("Keypad.TButton", font=button_font, padding=(5,10),height=100)
        
            
                
            

            #print(self.target_entry_name)
            
            for i in range(cols*2): # Configure columns to expand
                 self.marks_widgets_frame.grid_columnconfigure(i, weight=1 if i%2==1 else 0)
            




        else:
            
            btn_canvas.pack(side=tk.BOTTOM)
            btn_canvas.create_window((0, 0), window=scrollable_frame_for_buttons, anchor="nw")
            btn_canvas.configure(yscrollcommand=btn_scrollbar.set)
            row_idx, col_idx = 0, 0
            max_cols = 4 # Adjust number of columns as desired
            button_width_chars = 14 # Approximate characters
            button_height_lines = 5 # Approximate lines
            button_width = 17
            button_height = 5
            wraplength=button_width_chars*7
            button_font = ('TkDefaultFont', 15)
            b = ttk.Style(); b.configure("Keypad.TButton", font=button_font, wraplength=button_width_chars*10,justify='center',padding=(0))
            for i, behavior_text in enumerate(combined_options):
                btn = ttk.Button(scrollable_frame_for_buttons, text=behavior_text,
                                padding=(0,19),# Rough estimate for pixel width
                                width=button_width_chars, style="Keypad.TButton",
                                command=lambda n=behavior_text: self.on_button_select(n))
                btn.grid(row=row_idx, column=col_idx, sticky="nsew", padx=2, pady=3)
                type_frame.grid_columnconfigure(col_idx, weight=1) # Allow columns to expand
                col_idx += 1
                if col_idx >= max_cols:
                    col_idx = 0
                    row_idx += 1
            if col_idx != 0: # Ensure last row also configures row weight if partially filled
                scrollable_frame_for_buttons.grid_rowconfigure(row_idx, weight=1)

        ttk.Label(main_frame, text="Comment (Optional):").pack(pady=5, anchor=tk.W, padx=5)
        self.comment_entry = ttk.Entry(main_frame, width=45)
        self.comment_entry.pack(pady=5, fill=tk.X, padx=5)
        
        self.on_template_select(None) # Initialize based on default selection
        return self.homework_type_combobox if self.log_marks_enabled else self.comment_entry

    def on_button_select(self, name):
        self.homework_type_var.set(name)
        self.apply()
        self.ok()

    def _on_press(self, key):
        current_text = self.target_entry.get()
        if key == '⌫': n = len(current_text)-1; self.target_entry.set(current_text[0:n])
        elif key == '.':
            if self.allow_decimal and '.' not in current_text: self.target_entry.set(self.target_entry.get()+ key)
        else: self.target_entry.set(self.target_entry.get()+ key)
        
    def _clear_entry(self): self.target_entry.set("")
    def _next_entry(self):
        if self.cte < self.tte: self.cte +=1
        else: self.cte = 0
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
        
    def _previous_entry(self):
        if self.cte < self.tte and self.cte > -2: self.cte -=1
        else: self.cte = (self.tte-1)
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
        
    def set_numpad(self, event, x):
        #print(x)
        self.cte = x
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
    



    def on_template_select(self, event):
        selected_name = self.homework_type_var.get()
        template = next((tpl for tpl_id, tpl in self.homework_templates.items() if tpl['name'] == selected_name), None)

        if template:
            self.num_items_var.set(str(template.get("num_items", 10)))
            if self.num_items_frame.winfo_ismapped(): self.num_items_spinbox.config(state=tk.DISABLED) # Disable if template provides it

            if self.log_marks_enabled and "default_marks" in template:
                for mark_id, var in self.mark_entry_vars.items():
                    var.set(str(template["default_marks"].get(mark_id, ""))) # Use template's default marks
        else: # Not a template, or template doesn't have these fields
            if self.num_items_frame.winfo_ismapped(): self.num_items_spinbox.config(state=tk.NORMAL)
            # Clear mark entries if not a template or template has no defaults
            # for var in self.mark_entry_vars.values(): var.set("") # Or set to individual mark_type defaults


    def apply(self):
        homework_type = self.homework_type_var.get().strip()
        comment = self.comment_entry.get().strip()
        num_items_val = None
        marks_data = {}

        if not homework_type:
            messagebox.showwarning("Input Required", "Please select or enter a homework type/name.", parent=self)
            self.result = None; return

        if self.log_marks_enabled:
            try: num_items_val = int(self.num_items_var.get())
            except ValueError:
                messagebox.showwarning("Invalid Input", "Number of items must be a valid integer.", parent=self)
                self.result = None; return
            if num_items_val <= 0 :
                messagebox.showwarning("Invalid Input", "Number of items must be positive.", parent=self)
                self.result = None; return

            for mark_id, var in self.mark_entry_vars.items():
                val_str = var.get().strip()
                if val_str: # Only store if a value is entered
                    # Try to convert to float if possible, else store as string
                    try: marks_data[mark_id] = float(val_str)
                    except ValueError: marks_data[mark_id] = val_str
        
        self.result = (homework_type, comment, marks_data if self.log_marks_enabled else None, num_items_val if self.log_marks_enabled else None)

class QuizScoreDialog(simpledialog.Dialog):
    # ... (same as v51)
    def __init__(self, parent, title, initial_quiz_name, mark_types, quiz_templates, default_num_questions, initial_num_questions_val):
        self.initial_quiz_name = initial_quiz_name
        self.mark_types = mark_types # List of dicts: {"id", "name", "default_points", ...}
        self.quiz_templates = quiz_templates # Dict: {template_id: {"name", "num_questions", "default_marks"}}
        self.default_num_questions = default_num_questions
        self.initial_num_questions_val = initial_num_questions_val
        self.result = None
        self.mark_entry_vars = {} # {mark_type_id: StringVar}
        super().__init__(parent, title)

    def body(self, master):
        main_frame = ttk.Frame(master); main_frame.pack(fill=tk.BOTH, expand=True)
        top_frame = ttk.Frame(main_frame); top_frame.grid(pady=5, sticky="ew", columnspan=3)
        ttk.Label(top_frame, text="Quiz Name/Template:").pack(side=tk.LEFT, padx=5)
        self.quiz_name_var = tk.StringVar(value=self.initial_quiz_name)
        
        # Combine quiz name suggestions and template names for the combobox
        template_names = [tpl['name'] for tpl_id, tpl in self.quiz_templates.items()]
        # Simple quiz name suggestions (can be expanded)
        name_suggestions = list(set([self.initial_quiz_name, "Pop Quiz", "Chapter Test"] + template_names))

        self.quiz_name_combobox = ttk.Combobox(top_frame, textvariable=self.quiz_name_var, values=sorted(name_suggestions), width=30)
        self.quiz_name_combobox.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.quiz_name_combobox.bind("<<ComboboxSelected>>", self.on_template_select)
        self.quiz_name_combobox.bind("<MouseWheel>", lambda event: "break")


        num_q_frame = ttk.Frame(main_frame); num_q_frame.grid(pady=5, sticky="ew")
        ttk.Label(num_q_frame, text="Number of Questions:").pack(side=tk.LEFT, padx=5)
        self.num_questions_var = tk.StringVar(value=str(self.initial_num_questions_val if self.initial_num_questions_val else self.default_num_questions))
        self.num_questions_spinbox = ttk.Spinbox(num_q_frame, from_=1, to=200, textvariable=self.num_questions_var, width=5)
        self.num_questions_spinbox.pack(side=tk.LEFT, padx=5)

        self.target_entry2 = []
        self.target_entry3 = []
        self.cte = -1

        marks_frame = ttk.LabelFrame(main_frame, text="Marks Breakdown"); marks_frame.grid(pady=10, column=0, row=2, sticky="nsew", padx=5)
        cols = 2 # Number of columns for mark entries
        current_col_mark = 0; current_row_mark = 0
        for i, mark_type in enumerate(self.mark_types):
            mark_id = mark_type["id"]; mark_name = mark_type["name"]
            ttk.Label(marks_frame, text=f"{mark_name}:").grid(row=current_row_mark, column=current_col_mark*2, sticky=tk.W, padx=5, pady=3)
            var = tk.StringVar()
            self.mark_entry_vars[mark_id] = var
            entry = ttk.Entry(marks_frame, textvariable=var, width=8)
            entry.grid(row=current_row_mark, column=current_col_mark*2 + 1, sticky=tk.EW, padx=5, pady=3)
            entry.bind("<FocusIn>", lambda x=i,x2=i: self.set_numpad(x,x2))
            self.target_entry2.append(var)
            self.target_entry3.append(mark_type["name"])
            self.cte = i
            self.tte = i
            current_col_mark += 1
            if current_col_mark >= cols: current_col_mark = 0; current_row_mark += 1
            
        self.keypad_frame = ttk.Frame(main_frame, relief='sunken',borderwidth=10)
        self.keypad_frame.grid(column=1,row=1, rowspan=4)
        self.keypad_frame.grid_propagate(True)
        self.allow_decimal = True
        self.mark_vars2 = {} # {mark_type_id: tk.StringVar()}
        for mt in self.mark_vars2:
            self.mark_vars2[mt["id"]] = tk.StringVar()
        
        for i, mt_config in enumerate(self.mark_vars2):
            label_text = mt_config["name"]
            if mt_config.get("is_extra_credit"): label_text += " (Bonus)"
        #print(self.mark_vars2)
        self.target_entry = self.mark_entry_vars[mark_type["id"]]
        self.target_entry_name = mark_type["name"]
        
        self.target_name_label = ttk.Label(self.keypad_frame,text=self.target_entry_name)
        self.target_name_label.grid(column=0,row=0,columnspan=9)
        
        buttons = [('7',1,0),('8',1,1),('9',1,2),('4',2,0),('5',2,1),('6',2,2),('1',3,0),('2',3,1),('3',3,2),('0',4,0),('.',4,1) if self.allow_decimal else (' ',4,1),('⌫',4,2),('/',2,3)]
        button_font = ('TkDefaultFont', 15)
        self._next_entry()
        for i in range(4): self.rowconfigure(i, minsize=2000,weight=1)
        for i in range(4): self.columnconfigure(i, weight=1)
        for (text, r, c) in buttons:
            if text == ' ': continue
            action = lambda x=text: self._on_press(x)
            ttk.Button(self.keypad_frame, text=text, command=action, style="Keypad.TButton",padding=17,width=5).grid(row=r, column=c, padx=1, pady=1, sticky="nsew")
        ttk.Button(self.keypad_frame, text="Clear", command=self._clear_entry, style="Keypad.TButton").grid(row=1, column=3, padx=1, pady=1, sticky="nsew")
        ttk.Button(self.keypad_frame, text='Next', command=self._next_entry, style="Keypad.TButton").grid(row=4,column=3,padx=1,pady=1,sticky='nsew')
        ttk.Button(self.keypad_frame, text='Previous', command=self._previous_entry, style="Keypad.TButton").grid(row=3,column=3,padx=1,pady=1,sticky='nsew')
        s = ttk.Style(); s.configure("Keypad.TButton", font=button_font, padding=(5,10),height=100)
        
            
                
            
            
        for i in range(cols*2): marks_frame.grid_columnconfigure(i, weight=1 if i%2==1 else 0)

        ttk.Label(main_frame, text="Comment (Optional):").grid(pady=(0,0), sticky="sw", column=0, row=3, padx=5)
        self.comment_entry = ttk.Entry(main_frame, width=45); self.comment_entry.grid(pady=(0), column=0, row=4, sticky="ews", padx=5)
        
        self.on_template_select(None) # Initialize based on current quiz name (might be a template)
        return self.quiz_name_combobox

    # Functions for NumPad
    def _on_press(self, key):
        current_text = self.target_entry.get()
        if key == '⌫': n = len(current_text)-1; self.target_entry.set(current_text[0:n])
        elif key == '.':
            if self.allow_decimal and '.' not in current_text: self.target_entry.set(self.target_entry.get()+ key)
        else: self.target_entry.set(self.target_entry.get()+ key)

    def _clear_entry(self): self.target_entry.set("")
    
    def _next_entry(self):
        if self.cte < self.tte: self.cte +=1
        else: self.cte = 0
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
        
    def _previous_entry(self):
        if self.cte < self.tte and self.cte > -2: self.cte -=1
        else: self.cte = (self.tte-1)
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
        
    def set_numpad(self, event, x):
        #print(x)
        self.cte = x
        self.target_entry = self.target_entry2[(self.cte)]
        self.target_entry_name = self.target_entry3[(self.cte)]
        self.target_name_label.configure(text=self.target_entry_name)
    
    # Continued code



    def on_template_select(self, event):
        selected_name = self.quiz_name_var.get()
        template = next((tpl for tpl_id, tpl in self.quiz_templates.items() if tpl['name'] == selected_name), None)
        if template:
            self.num_questions_var.set(str(template.get("num_questions", self.default_num_questions)))
            self.num_questions_spinbox.config(state=tk.DISABLED) # Disable if template provides it
            if "default_marks" in template:
                for mark_id, var in self.mark_entry_vars.items():
                    var.set(str(template["default_marks"].get(mark_id, ""))) # Use template's default marks
        else: # Not a template, or template doesn't have these fields
            self.num_questions_spinbox.config(state=tk.NORMAL)
            # Optionally clear marks or set to individual mark_type defaults when not a template
            # for mark_id, var in self.mark_entry_vars.items(): var.set("")

    def apply(self):
        quiz_name = self.quiz_name_var.get().strip(); comment = self.comment_entry.get().strip()
        try: num_questions_actual = int(self.num_questions_var.get())
        except ValueError: messagebox.showwarning("Invalid Input", "Number of questions must be an integer.", parent=self); self.result = None; return
        if num_questions_actual <= 0: messagebox.showwarning("Invalid Input", "Number of questions must be positive.", parent=self); self.result = None; return

        marks_data = {}
        total_marks_entered = 0 # Sum of counts for each mark type
        for mark_id, var in self.mark_entry_vars.items():
            val_str = var.get().strip()
            if val_str:
                try: 
                    val_int = int(val_str)
                    if val_int < 0: messagebox.showwarning("Invalid Input", f"Mark for '{mark_id}' cannot be negative.",parent=self); self.result=None; return
                    marks_data[mark_id] = val_int
                    # Only sum if it's a primary mark contributing to total questions (heuristic)
                    mark_type_obj = next((mt for mt in self.mark_types if mt["id"] == mark_id), None)
                    if mark_type_obj and mark_type_obj.get("contributes_to_total", True):
                        total_marks_entered += val_int
                except ValueError: messagebox.showwarning("Invalid Input", f"Marks for '{mark_id}' must be integers.", parent=self); self.result = None; return
        
        # Validate that sum of primary marks entered does not exceed num_questions_actual
        # This logic assumes 'contributes_to_total' correctly identifies marks that sum up to total questions.
        if total_marks_entered > num_questions_actual:
             messagebox.showwarning("Marks Exceed Questions", f"The sum of primary marks ({total_marks_entered}) exceeds the total number of questions ({num_questions_actual}).\nPlease check your entries.", parent=self)
             self.result = None; return

        if quiz_name: self.result = (quiz_name, marks_data, comment, num_questions_actual)
        else: messagebox.showwarning("Input Required", "Quiz name cannot be empty.", parent=self); self.result = None

class LiveQuizMarkDialog(simpledialog.Dialog):
    # ... (same as v51)
    def __init__(self, parent, student_id, app_instance, session_type="Quiz"): # session_type can be Quiz or Homework
        self.student_id = student_id
        self.app = app_instance
        self.student_name = self.app.students[student_id]['full_name']
        self.session_type_display = session_type
        self.result = None # "correct", "incorrect", "skip"
        super().__init__(parent, f"Mark {session_type} for {self.student_name}")

    def body(self, master):
        if self.session_type_display == "Quiz":
            current_score_info = self.app.live_quiz_scores.get(self.student_id, {"correct": 0, "total_asked": 0})
            score_text = f"Current Score: {current_score_info['correct']} / {current_score_info['total_asked']}"
            ttk.Label(master, text=score_text, font=("", 10)).pack(pady=(5,0))
            ttk.Label(master, text=f"Mark next question for {self.student_name}:").pack(pady=(5,10))
        else: # Homework or other types could be added
            ttk.Label(master, text=f"Update {self.session_type_display} status for {self.student_name}:").pack(pady=(5,10))
        return master # No specific focus needed as it's button driven

    def buttonbox(self): # Override to provide custom buttons
        button_frame = ttk.Frame(self)
        button_frame.pack(pady=10)
        if self.session_type_display == "Quiz":
            ttk.Button(button_frame, text="Correct ✔️", command=lambda: self.set_result_and_close("correct"), width=12).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Incorrect ❌", command=lambda: self.set_result_and_close("incorrect"), width=12).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="Skip/Pass ⏭️", command=lambda: self.set_result_and_close("skip"), width=12).pack(side=tk.LEFT, padx=5)
        # Add buttons for other session types if needed
        ttk.Button(button_frame, text="Cancel", command=self.cancel, width=10).pack(side=tk.LEFT, padx=5)
        self.bind("<Escape>", lambda e: self.cancel())
        # Could bind 1,2,3 to correct, incorrect, skip for faster input

    def set_result_and_close(self, res_val):
        self.result = res_val
        self.destroy() # Close the dialog

    def apply(self): pass # Not strictly needed due to custom button actions

class LiveHomeworkMarkDialog(simpledialog.Dialog): # New
    def __init__(self, parent, student_id, app_instance, session_mode, current_hw_data):
        self.student_id = student_id
        self.app = app_instance
        self.student_name = self.app.students[student_id]['full_name']
        self.session_mode = session_mode # "Yes/No" or "Select"
        self.current_hw_data = current_hw_data # Existing data for this student in this session
        self.result_actions = None # Will store dict for Yes/No or list for Select
        
        # For Yes/No mode:
        self.homework_item_vars = {} # {homework_type_id: StringVar}
        # For Select mode:
        self.homework_option_vars = {} # {option_name: BooleanVar}

        super().__init__(parent, f"Mark Homework: {self.student_name} ({self.session_mode} Mode)")

    def body(self, master):
        main_frame = ttk.Frame(master); main_frame.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)
        
        current_session_name_label = ttk.Label(main_frame, text=f"Session: {self.app.current_live_homework_name}", font=("", 11, "italic"))
        current_session_name_label.pack(pady=(0,10))

        if self.session_mode == "Yes/No":
            # Display a list of homework types defined in settings for Yes/No mode
            # self.app.all_homework_session_types (list of dicts: {"id", "name"})'
            select_options = self.app.settings.get("live_homework_select_mode_options", DEFAULT_HOMEWORK_SESSION_BUTTONS.copy())
            if not self.app.all_homework_session_types:
                 ttk.Label(main_frame, text="No homework types configured for 'Yes/No' mode in settings.").pack()
                 return master

            yes_no_frame = ttk.Frame(main_frame)
            yes_no_frame.pack(expand=True, fill=tk.BOTH)
            #print(self.app.all_homework_session_types)
            for hw_type_item in self.app.all_homework_session_types:
                hw_id = hw_type_item["id"]; hw_name = hw_type_item["name"]
                item_frame = ttk.Frame(yes_no_frame); item_frame.pack(fill=tk.X, pady=2)
                ttk.Label(item_frame, text=f"{hw_name}:", width=20, anchor=tk.W).pack(side=tk.LEFT, padx=5)
                
                var = tk.StringVar(value=self.current_hw_data.get(hw_id, "Pending").lower()) # Default to current or "Pending"
                self.homework_item_vars[hw_id] = var
                
                rb_yes = ttk.Radiobutton(item_frame, text="Yes", variable=var, value="yes")
                rb_yes.pack(side=tk.LEFT, padx=3)
                rb_no = ttk.Radiobutton(item_frame, text="No", variable=var, value="no")
                rb_no.pack(side=tk.LEFT, padx=3)
                rb_clear = ttk.Radiobutton(item_frame, text="Pending", variable=var, value="pending") # Clear/Pending option
                rb_clear.pack(side=tk.LEFT, padx=3)


        elif self.session_mode == "Select":
            # Display buttons/checkboxes based on DEFAULT_HOMEWORK_SESSION_BUTTONS or a customizable list from settings
            select_options = self.app.settings.get("live_homework_select_mode_options", DEFAULT_HOMEWORK_SESSION_BUTTONS.copy())
            if not select_options:
                 ttk.Label(main_frame, text="No options configured for 'Select' mode in settings.").pack()
                 return master
            
            select_frame = ttk.Frame(main_frame)
            select_frame.pack(expand=True, fill=tk.BOTH)
            ttk.Label(select_frame, text="Select applicable statuses:").grid(sticky="nw", pady=(0,5))

            # Get current selections for this student
            current_selected_options = self.current_hw_data.get("selected_options", [])

            # Use Checkbuttons for multi-select
            cols = 2; current_col = 0; current_row_sel = 1
            for option_info in select_options: # option_info is a dict, e.g., {"name": "Done"}
                option_name = option_info["name"]
                var = tk.BooleanVar(value=(option_name in current_selected_options))
                self.homework_option_vars[option_name] = var
                cb = ttk.Checkbutton(select_frame, text=option_name, variable=var)
                cb.grid(row=current_row_sel, column=current_col, sticky=tk.W, padx=5, pady=2)
                current_col += 1
                if current_col >= cols: current_col = 0; current_row_sel +=1
            for i in range(cols): select_frame.grid_columnconfigure(i, weight=1)

        return master

    def apply(self):
        if self.session_mode == "Yes/No":
            self.result_actions = {}
            for hw_id, var in self.homework_item_vars.items():
                status = var.get()
                if status != "pending": # Only store "yes" or "no"
                    self.result_actions[hw_id] = status
        elif self.session_mode == "Select":
            self.result_actions = []
            for option_name, var in self.homework_option_vars.items():
                if var.get():
                    self.result_actions.append(option_name)
        # If result_actions is empty (e.g. all pending in Yes/No, or nothing selected in Select)
        # it will be handled by the command to potentially clear the student's entry.

class ExitConfirmationDialog(simpledialog.Dialog): # Same as v50
    def __init__(self, parent, title): self.choice = None; super().__init__(parent, title)
    def body(self, master): ttk.Label(master, text="Do you want to save changes before quitting?").pack(pady=10, padx=10); return None
    def buttonbox(self):
        box = ttk.Frame(self)
        box.columnconfigure(0, weight=1); box.columnconfigure(1, weight=1); box.columnconfigure(2, weight=1)
        ttk.Button(box, text="Save and Quit", width=15, command=self.save_quit).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(box, text="Don't Save and Quit", width=20, command=self.no_save_quit).grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(box, text="Cancel", width=10, command=self.cancel).grid(row=0, column=2, padx=5, pady=5, sticky="ew")
        self.bind("<Return>", lambda e: self.save_quit()); self.bind("<Escape>", self.cancel)
        box.pack(fill=tk.X, padx=5, pady=5)
    def save_quit(self): self.result = "save_quit"; self.destroy()
    def no_save_quit(self): self.result = "no_save_quit"; self.destroy()

class ImportExcelOptionsDialog(simpledialog.Dialog): # Same as v50, but ensure app_instance is passed
    def __init__(self, parent, app_instance):
        self.app_instance = app_instance
        self.file_path_var = tk.StringVar()
        self.import_incidents_var = tk.BooleanVar(value=False)
        self.student_sheet_var = tk.StringVar()
        self.workbook_sheet_names = []
        super().__init__(parent, "Import Data from Excel")
    def body(self, master):
        ttk.Label(master, text="Excel File:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        self.file_entry = ttk.Entry(master, textvariable=self.file_path_var, width=40, state="readonly")
        self.file_entry.grid(row=0, column=1, padx=5, pady=2)
        ttk.Button(master, text="Browse...", command=self._browse_file).grid(row=0, column=2, padx=5, pady=2)
        ttk.Label(master, text="Student Info Sheet:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.student_sheet_combo = ttk.Combobox(master, textvariable=self.student_sheet_var, width=37, state="disabled")
        self.student_sheet_combo.grid(row=1, column=1, padx=5, pady=2)
        ttk.Checkbutton(master, text="Import incidents from individual student sheets\n(matches sheet names to current students)", variable=self.import_incidents_var).grid(row=2, column=0, columnspan=3, sticky="w", padx=5, pady=5)
        return self.file_entry
    def _browse_file(self):
        path = filedialog.askopenfilename(title="Select Excel File", filetypes=[("Excel files", "*.xlsx *.xls *.xlsm")])
        if path:
            self.file_path_var.set(path)
            try:
                wb = load_workbook(filename=path, read_only=True, data_only=True)
                self.workbook_sheet_names = wb.sheetnames
                self.student_sheet_combo['values'] = [""] + self.workbook_sheet_names # Add blank option
                common_sheet_names = ["Students", "Student List", "Roster", "Students Info", "Sheet1"] # Common names
                found_common = next((name for name in common_sheet_names if name in self.workbook_sheet_names), "")
                self.student_sheet_var.set(found_common if found_common else (self.workbook_sheet_names[0] if self.workbook_sheet_names else ""))
                self.student_sheet_combo.config(state="readonly")
            except Exception as e:
                messagebox.showerror("Excel Error", f"Could not read Excel file: {e}", parent=self.app_instance.root)
                self.student_sheet_combo['values'] = [""]; self.student_sheet_var.set(""); self.student_sheet_combo.config(state="disabled")
    def validate(self):
        if not self.file_path_var.get() or not os.path.exists(self.file_path_var.get()):
            messagebox.showerror("File Error", "Please select a valid Excel file.", parent=self.app_instance.root); return False
        # No need to check workbook_sheet_names here as _browse_file handles errors.
        # Student sheet can be blank if user doesn't want to import students.
        return True
    def apply(self):
        if not self.validate(): self.result = None; return
        self.result = (self.file_path_var.get(), self.import_incidents_var.get(), self.student_sheet_var.get() or None) # Return None if sheet is blank

class SizeInputDialog(simpledialog.Dialog): # Same as v50
    def __init__(self, parent, title, initial_w, initial_h, status):
        self.status = status
        self.initial_w, self.initial_h = initial_w, initial_h
        self.width_var = tk.IntVar(value=initial_w); self.height_var = tk.IntVar(value=initial_h)
        super().__init__(parent, title)
    def body(self, master):
        ttk.Label(master, text="Width:").grid(row=0, column=0, sticky="W", padx=5, pady=5)
        self.width_entry = ttk.Spinbox(master, from_=MIN_STUDENT_BOX_WIDTH, to=1000, textvariable=self.width_var, width=7)
        self.width_entry.grid(row=0, column=1, padx=5, pady=5)
        self.width_reset_entry = ttk.Button(master,command=self.reset_width ,text="Reset Width")
        self.width_reset_entry.grid(row=0,column=2,padx=5,pady=5)
        
        ttk.Label(master, text="Height:").grid(row=1, column=0, sticky="W", padx=5, pady=5)
        self.height_entry = ttk.Spinbox(master, from_=MIN_STUDENT_BOX_HEIGHT, to=1000, textvariable=self.height_var, width=7)
        self.height_entry.grid(row=1, column=1, padx=5, pady=5)
        self.height_reset_entry = ttk.Button(master,command=self.reset_height, text="Reset Height")
        self.height_reset_entry.grid(row=1,column=2,padx=5,pady=5)
        return self.width_entry
    
    def reset_width(self):
        if self.status:
            self.width_var.set(DEFAULT_STUDENT_BOX_WIDTH)
        else:
            self.width_var.set(REBBI_DESK_WIDTH)
        
    def reset_height(self):
        #self.height_var.set(DEFAULT_STUDENT_BOX_HEIGHT)
        if self.status:
            self.height_var.set(DEFAULT_STUDENT_BOX_HEIGHT)
        else:
            self.height_var.set(REBBI_DESK_HEIGHT)
    
    def validate(self):
        try:
            w, h = self.width_var.get(), self.height_var.get()
            if w < MIN_STUDENT_BOX_WIDTH or h < MIN_STUDENT_BOX_HEIGHT or w > 1000 or h > 1000:
                messagebox.showerror("Invalid Size", f"Width ({MIN_STUDENT_BOX_WIDTH}-1000), Height ({MIN_STUDENT_BOX_HEIGHT}-1000).", parent=self); return False
            return True
        except tk.TclError: messagebox.showerror("Invalid Input", "Valid numbers for W/H.", parent=self); return False
    def apply(self):
        if not self.validate(): self.result = None; return
        self.result = (self.width_var.get(), self.height_var.get())

class StudentStyleDialog(simpledialog.Dialog):
    # ... (same as v51)
    def __init__(self, parent, title, student_data, app):
        self.student_data = student_data
        self.app = app # For default settings and font list
        self.result = [] # List of (property, old_value, new_value) tuples for Command
        self.initial_overrides = student_data.get("style_overrides", {}).copy()
        super().__init__(parent, title)

    def body(self, master):
        prop_frame = ttk.Frame(master); prop_frame.pack(padx=10,pady=10)
        row_idx = 0
        # Fill Color
        ttk.Label(prop_frame, text="Box Fill Color:").grid(row=row_idx, column=0, sticky=tk.W, pady=3)
        self.fill_color_var = tk.StringVar(value=self.initial_overrides.get("fill_color", ""))
        self.fill_color_entry = ttk.Entry(prop_frame, textvariable=self.fill_color_var, width=15)
        self.fill_color_entry.grid(row=row_idx, column=1, pady=3, padx=2)
        ttk.Button(prop_frame, text="Choose...", command=lambda v=self.fill_color_var: self.choose_color(v)).grid(row=row_idx, column=2, pady=3, padx=2)
        ttk.Button(prop_frame, text="Default", command=lambda v=self.fill_color_var, k="fill_color": self.reset_to_default(v,k)).grid(row=row_idx, column=3, pady=3, padx=2)
        row_idx+=1
        # Outline Color
        ttk.Label(prop_frame, text="Box Outline Color:").grid(row=row_idx, column=0, sticky=tk.W, pady=3)
        self.outline_color_var = tk.StringVar(value=self.initial_overrides.get("outline_color", ""))
        self.outline_color_entry = ttk.Entry(prop_frame, textvariable=self.outline_color_var, width=15)
        self.outline_color_entry.grid(row=row_idx, column=1, pady=3, padx=2)
        ttk.Button(prop_frame, text="Choose...", command=lambda v=self.outline_color_var: self.choose_color(v)).grid(row=row_idx, column=2, pady=3, padx=2)
        ttk.Button(prop_frame, text="Default", command=lambda v=self.outline_color_var, k="outline_color": self.reset_to_default(v,k)).grid(row=row_idx, column=3, pady=3, padx=2)
        row_idx+=1
        # Font Family
        ttk.Label(prop_frame, text="Font Family:").grid(row=row_idx, column=0, sticky=tk.W, pady=3)
        self.font_family_var = tk.StringVar(value=self.initial_overrides.get("font_family", ""))
        available_fonts = self.app.settings.get("available_fonts", [DEFAULT_FONT_FAMILY])
        self.font_family_combo = ttk.Combobox(prop_frame, textvariable=self.font_family_var, values=available_fonts, width=20, state="readonly")
        self.font_family_combo.grid(row=row_idx, column=1, columnspan=2, pady=3, padx=2, sticky=tk.EW)
        self.font_family_combo.bind("<MouseWheel>", lambda event: "break")
        ttk.Button(prop_frame, text="Default", command=lambda v=self.font_family_var, k="font_family": self.reset_to_default(v,k)).grid(row=row_idx, column=3, pady=3, padx=2)
        row_idx+=1
        # Font Size
        ttk.Label(prop_frame, text="Font Size (pts):").grid(row=row_idx, column=0, sticky=tk.W, pady=3)
        self.font_size_var = tk.IntVar(value=self.initial_overrides.get("font_size", 0) or 0) # Ensure it's int, 0 for default placeholder
        self.font_size_spinbox = ttk.Spinbox(prop_frame, from_=6, to=30, textvariable=self.font_size_var, width=5)
        self.font_size_spinbox.grid(row=row_idx, column=1, pady=3, padx=2, sticky=tk.W)
        ttk.Button(prop_frame, text="Default", command=lambda v=self.font_size_var, k="font_size": self.reset_to_default(v,k)).grid(row=row_idx, column=3, pady=3, padx=2)
        row_idx+=1
        # Font Color
        ttk.Label(prop_frame, text="Font Color:").grid(row=row_idx, column=0, sticky=tk.W, pady=3)
        self.font_color_var = tk.StringVar(value=self.initial_overrides.get("font_color", ""))
        self.font_color_entry = ttk.Entry(prop_frame, textvariable=self.font_color_var, width=15)
        self.font_color_entry.grid(row=row_idx, column=1, pady=3, padx=2)
        ttk.Button(prop_frame, text="Choose...", command=lambda v=self.font_color_var: self.choose_color(v)).grid(row=row_idx, column=2, pady=3, padx=2)
        ttk.Button(prop_frame, text="Default", command=lambda v=self.font_color_var, k="font_color": self.reset_to_default(v,k)).grid(row=row_idx, column=3, pady=3, padx=2)
        return self.fill_color_entry # Initial focus
    def choose_color(self, var_to_set):
        initial_color = var_to_set.get() if var_to_set.get() else None
        color_code = colorchooser.askcolor(title="Choose color", initialcolor=initial_color, parent=self)
        if color_code and color_code[1]: var_to_set.set(color_code[1])
    def reset_to_default(self, var_to_set, key):
        # For string vars (colors, font family), set to empty string to signify "use app default"
        # For int var (font size), set to 0 to signify "use app default"
        if isinstance(var_to_set, tk.StringVar): var_to_set.set("")
        elif isinstance(var_to_set, tk.IntVar): var_to_set.set(0)
    def apply(self):
        style_props_vars = {
            "fill_color": self.fill_color_var, "outline_color": self.outline_color_var,
            "font_family": self.font_family_var, "font_size": self.font_size_var,
            "font_color": self.font_color_var
        }
        for prop_key, tk_var in style_props_vars.items():
            new_val = tk_var.get()
            # Standardize "default" representation: None for deletion from overrides
            # Empty string for colors/font family, 0 for font size, means use default
            if isinstance(new_val, str) and not new_val.strip(): final_new_val = None
            elif isinstance(new_val, int) and new_val == 0: final_new_val = None
            else: final_new_val = new_val
            
            old_val_from_overrides = self.initial_overrides.get(prop_key) # This will be None if key didn't exist
            if final_new_val != old_val_from_overrides:
                self.result.append((prop_key, old_val_from_overrides, final_new_val))

class ExportFilterDialog(simpledialog.Dialog):
    # ... (updated for homework filters)
    def __init__(self, parent, students_dict, all_behaviors_list, all_homework_types_list, default_settings, earliest_date):
        self.students_dict = students_dict
        self.all_behaviors_list = sorted(list(set(all_behaviors_list)))
        self.all_homework_types_list = ((all_homework_types_list)) # New
        self.earliest_date=earliest_date
        self.default_settings = default_settings
        self.result = None
        super().__init__(parent, "Export Log Options")

    def body(self, master):
        frame = ttk.Frame(master); frame.pack(padx=10, pady=10)
        # Date Range
        date_frame = ttk.LabelFrame(frame, text="Date Range"); date_frame.grid(pady=5,column=0,row=0,columnspan=3, sticky="ew")
        ttk.Label(date_frame, text="Start Date:").grid(row=0, column=0, padx=5, pady=3, sticky=tk.W)
        self.start_date_var = tk.StringVar()
        #ttkcal = Calendar(firstweekday=calendar.SUNDAY)
        #ttkcal.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        if DateEntry: self.start_date_entry = DateEntryCustom(date_frame, textvariable=self.start_date_var, date_pattern='yyyy-mm-dd', width=12); print("Dateentry") # See DateEntryCustom for what to do
        else: self.start_date_entry = ttk.Entry(date_frame, textvariable=self.start_date_var, width=12)
        self.start_date_entry.grid(row=0, column=1, padx=5, pady=3)
        
        self.start_date_var.set(value=self.earliest_date)
        ttk.Button(date_frame, text="Popup", command=lambda: self.show_cal_start(date_frame)).grid(row=0, column=2, padx=5, pady=3)
        ttk.Label(date_frame, text="End Date:").grid(row=1, column=0, padx=5, pady=3, sticky=tk.W)
        self.end_date_var = tk.StringVar()
        
        if DateEntry: self.end_date_entry = DateEntry(date_frame, textvariable=self.end_date_var, date_pattern='yyyy-mm-dd', width=12)
        else: self.end_date_entry = ttk.Entry(date_frame, textvariable=self.end_date_var, width=12)
        self.end_date_entry.grid(row=1, column=1, padx=5, pady=3)
        ttk.Button(date_frame, text="Clear Dates", command=self.clear_dates).grid(row=1, column=2, rowspan=2, padx=5, pady=3)

        # Students
        student_frame = ttk.LabelFrame(frame, text="Students"); student_frame.grid(pady=5,column=0,row=1, sticky="nsew")
        self.student_filter_var = tk.StringVar(value="all")
        ttk.Radiobutton(student_frame, text="All Students", variable=self.student_filter_var, value="all", command=self.toggle_student_list_state).pack(anchor=tk.W)
        ttk.Radiobutton(student_frame, text="Selected Students:", variable=self.student_filter_var, value="specific", command=self.toggle_student_list_state).pack(anchor=tk.W)
        self.student_list_frame = ttk.Frame(student_frame)
        self.student_list_frame.pack(fill=tk.X, padx=(20,0))
        self.student_listbox = tk.Listbox(self.student_list_frame, selectmode=tk.MULTIPLE, height=5, exportselection=False)
        sorted_students = sorted(self.students_dict.values(), key=lambda s: (s['last_name'], s['first_name']))
        self.student_listbox_map = {} # display_name -> student_id
        for i, s_data in enumerate(sorted_students):
            display_name = f"{s_data['last_name']}, {s_data['first_name']}" + (f" ({s_data.get('nickname')})" if s_data.get('nickname') else "")
            self.student_listbox.insert(tk.END, display_name)
            self.student_listbox_map[display_name] = s_data["id"]
        self.student_listbox.pack(side=tk.LEFT, fill=tk.X, expand=True, pady=(0,3))
        student_scroll = ttk.Scrollbar(self.student_list_frame, orient=tk.VERTICAL, command=self.student_listbox.yview)
        student_scroll.pack(side=tk.RIGHT, fill=tk.Y, pady=(0,3)); self.student_listbox.config(yscrollcommand=student_scroll.set)

        # Behaviors (for Behavior and Quiz logs)
        behavior_frame = ttk.LabelFrame(frame, text="Behavior/Quiz Types"); behavior_frame.grid(pady=5, padx=5, column=1,row=1, sticky="nsew")
        self.behavior_filter_var = tk.StringVar(value="all")
        ttk.Radiobutton(behavior_frame, text="All Behavior/Quiz Types", variable=self.behavior_filter_var, value="all", command=self.toggle_behavior_list_state).pack(anchor=tk.W)
        ttk.Radiobutton(behavior_frame, text="Selected Behavior/Quiz Types:", variable=self.behavior_filter_var, value="specific", command=self.toggle_behavior_list_state).pack(anchor=tk.W)
        self.behavior_list_frame = ttk.Frame(behavior_frame)
        self.behavior_list_frame.pack(fill=tk.X, padx=(20,0))
        self.behavior_listbox = tk.Listbox(self.behavior_list_frame, selectmode=tk.MULTIPLE, height=5, exportselection=False)
        for b_name in self.all_behaviors_list: self.behavior_listbox.insert(tk.END, b_name)
        self.behavior_listbox.pack(side=tk.LEFT, fill=tk.X, expand=True, pady=(0,3))
        bh_scroll = ttk.Scrollbar(self.behavior_list_frame, orient=tk.VERTICAL, command=self.behavior_listbox.yview)
        bh_scroll.pack(side=tk.RIGHT, fill=tk.Y, pady=(0,3)); self.behavior_listbox.config(yscrollcommand=bh_scroll.set)

        # Homework Types (New)
        homework_frame = ttk.LabelFrame(frame, text="Homework Types"); homework_frame.grid(pady=5,padx=5,column=0,row=2,rowspan=2, sticky="ew")
        self.homework_filter_var = tk.StringVar(value="all")
        ttk.Radiobutton(homework_frame, text="All Homework Types", variable=self.homework_filter_var, value="all", command=self.toggle_homework_list_state).pack(anchor=tk.W)
        ttk.Radiobutton(homework_frame, text="Selected Homework Types:", variable=self.homework_filter_var, value="specific", command=self.toggle_homework_list_state).pack(anchor=tk.W)
        self.homework_list_frame = ttk.Frame(homework_frame)
        self.homework_list_frame.pack(fill=tk.X, padx=(20,0))
        self.homework_listbox = tk.Listbox(self.homework_list_frame, selectmode=tk.MULTIPLE, height=5, exportselection=False)
        for hw_name in self.all_homework_types_list: self.homework_listbox.insert(tk.END, hw_name) # Use combined list of names
        self.homework_listbox.pack(side=tk.LEFT, fill=tk.X, expand=True, pady=(0,3))
        hw_scroll = ttk.Scrollbar(self.homework_list_frame, orient=tk.VERTICAL, command=self.homework_listbox.yview)
        hw_scroll.pack(side=tk.RIGHT, fill=tk.Y, pady=(0,3)); self.homework_listbox.config(yscrollcommand=hw_scroll.set)


        # Log Type Inclusion
        include_frame = ttk.LabelFrame(frame, text="Include Log Types"); include_frame.grid(pady=5,column=1,row=2, sticky="nsew")
        self.include_behavior_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(include_frame, text="Behavior Logs", variable=self.include_behavior_var).pack(anchor=tk.W, padx=5)
        self.include_quiz_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(include_frame, text="Quiz Logs", variable=self.include_quiz_var).pack(anchor=tk.W, padx=5)
        self.include_homework_var = tk.BooleanVar(value=True) # New
        ttk.Checkbutton(include_frame, text="Homework Logs", variable=self.include_homework_var).pack(anchor=tk.W, padx=5)

        # Output Options
        output_options_frame = ttk.LabelFrame(frame, text="Excel Output Options"); output_options_frame.grid(pady=5, column=1,row=3, sticky="nsew")
        self.separate_sheets_var = tk.BooleanVar(value=self.default_settings.get("excel_export_separate_sheets_by_default", True))
        ttk.Checkbutton(output_options_frame, text="Separate sheets for Behavior, Quiz, Homework", variable=self.separate_sheets_var).pack(anchor=tk.W, padx=5)
        self.include_summaries_var = tk.BooleanVar(value=self.default_settings.get("excel_export_include_summaries_by_default", True))
        ttk.Checkbutton(output_options_frame, text="Include summary sheet", variable=self.include_summaries_var).pack(anchor=tk.W, padx=5)

        self.toggle_student_list_state(); self.toggle_behavior_list_state(); self.toggle_homework_list_state()
        return frame

    def clear_dates(self): self.start_date_var.set(""); self.end_date_var.set("")
    def toggle_student_list_state(self): self.student_listbox.config(state=tk.NORMAL if self.student_filter_var.get() == "specific" else tk.DISABLED)
    def toggle_behavior_list_state(self): self.behavior_listbox.config(state=tk.NORMAL if self.behavior_filter_var.get() == "specific" else tk.DISABLED)
    def toggle_homework_list_state(self): self.homework_listbox.config(state=tk.NORMAL if self.homework_filter_var.get() == "specific" else tk.DISABLED)

    def show_cal_start(self, master):
        self.calendar_start = CalendarPopup(master, self.start_date_var)
    
    def show_cal_end(self, master):
        self.calendar_end = CalendarPopup(master, self.end_date_var)
    
    def apply(self):
        start_dt, end_dt = None, None
        try:
            if self.start_date_var.get(): start_dt = datetime.strptime(self.start_date_var.get(), '%Y-%m-%d').date()
            if self.end_date_var.get(): end_dt = datetime.strptime(self.end_date_var.get(), '%Y-%m-%d').date()
            if start_dt and end_dt and start_dt > end_dt:
                messagebox.showerror("Invalid Dates", "Start date cannot be after end date.", parent=self); return
        except ValueError: messagebox.showerror("Invalid Date Format", "Please use YYYY-MM-DD for dates.", parent=self); return

        selected_s_ids = [self.student_listbox_map[self.student_listbox.get(i)] for i in self.student_listbox.curselection()] if self.student_filter_var.get() == "specific" else []
        selected_b_names = [self.behavior_listbox.get(i) for i in self.behavior_listbox.curselection()] if self.behavior_filter_var.get() == "specific" else []
        selected_hw_names = [self.homework_listbox.get(i) for i in self.homework_listbox.curselection()] if self.homework_filter_var.get() == "specific" else [] # New

        if not (self.include_behavior_var.get() or self.include_quiz_var.get() or self.include_homework_var.get()):
            messagebox.showwarning("No Log Types", "Please select at least one log type to include.", parent=self); return

        self.result = {
            "start_date": start_dt, "end_date": end_dt,
            "selected_students": self.student_filter_var.get(), "student_ids": selected_s_ids,
            "selected_behaviors": self.behavior_filter_var.get(), "behaviors_list": selected_b_names,
            "selected_homework_types": self.homework_filter_var.get(), "homework_types_list": selected_hw_names, # New
            "include_behavior_logs": self.include_behavior_var.get(),
            "include_quiz_logs": self.include_quiz_var.get(),
            "include_homework_logs": self.include_homework_var.get(), # New
            "separate_sheets_by_log_type": self.separate_sheets_var.get(),
            "include_summaries": self.include_summaries_var.get()
        }

class AttendanceReportDialog(simpledialog.Dialog):
    def __init__(self, parent, students_dict):
        self.students_dict = students_dict
        self.result = None
        super().__init__(parent, "Generate Attendance Report")

    def body(self, master):
        frame = ttk.Frame(master); frame.pack(padx=10, pady=10)

        date_frame = ttk.LabelFrame(frame, text="Report Date Range"); date_frame.pack(pady=5, fill=tk.X)
        ttk.Label(date_frame, text="Start Date:").grid(row=0, column=0, padx=5, pady=3, sticky=tk.W)
        self.start_date_var = tk.StringVar(value=(datetime_date.today() - timedelta(days=7)).strftime('%Y-%m-%d'))
        if DateEntry:
            self.start_date_entry = DateEntry(date_frame, textvariable=self.start_date_var, date_pattern='yyyy-mm-dd', width=12)
        else:
            self.start_date_entry = ttk.Entry(date_frame, textvariable=self.start_date_var, width=12)
        self.start_date_entry.grid(row=0, column=1, padx=5, pady=3)

        ttk.Label(date_frame, text="End Date:").grid(row=1, column=0, padx=5, pady=3, sticky=tk.W)
        self.end_date_var = tk.StringVar(value=datetime_date.today().strftime('%Y-%m-%d'))
        if DateEntry:
            self.end_date_entry = DateEntry(date_frame, textvariable=self.end_date_var, date_pattern='yyyy-mm-dd', width=12)
        else:
            self.end_date_entry = ttk.Entry(date_frame, textvariable=self.end_date_var, width=12)
        self.end_date_entry.grid(row=1, column=1, padx=5, pady=3)

        student_frame = ttk.LabelFrame(frame, text="Select Students"); student_frame.pack(pady=5, fill=tk.X)
        self.student_listbox = tk.Listbox(student_frame, selectmode=tk.MULTIPLE, height=8, exportselection=False)
        self.sorted_student_list_for_dialog = sorted(self.students_dict.values(), key=lambda s: (s['last_name'], s['first_name']))
        self.student_id_map_for_dialog = {} # display_name -> student_id
        for i, s_data in enumerate(self.sorted_student_list_for_dialog):
            display_name = f"{s_data['last_name']}, {s_data['first_name']}" + (f" ({s_data.get('nickname')})" if s_data.get('nickname') else "")
            self.student_listbox.insert(tk.END, display_name)
            self.student_id_map_for_dialog[display_name] = s_data["id"]
            self.student_listbox.selection_set(i) # Select all by default

        self.student_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, pady=3, padx=3)
        student_scroll = ttk.Scrollbar(student_frame, orient=tk.VERTICAL, command=self.student_listbox.yview)
        student_scroll.pack(side=tk.RIGHT, fill=tk.Y, pady=3, padx=3)
        self.student_listbox.config(yscrollcommand=student_scroll.set)
        
        select_buttons_frame = ttk.Frame(student_frame)
        select_buttons_frame.pack(fill=tk.X, pady=(0,3))
        ttk.Button(select_buttons_frame, text="Select All", command=lambda: self.student_listbox.selection_set(0, tk.END)).pack(side=tk.LEFT, padx=5)
        ttk.Button(select_buttons_frame, text="Deselect All", command=lambda: self.student_listbox.selection_clear(0, tk.END)).pack(side=tk.LEFT, padx=5)


        return frame

    def apply(self):
        start_dt, end_dt = None, None
        try:
            if self.start_date_var.get(): start_dt = datetime.strptime(self.start_date_var.get(), '%Y-%m-%d').date()
            if self.end_date_var.get(): end_dt = datetime.strptime(self.end_date_var.get(), '%Y-%m-%d').date()
            if not start_dt or not end_dt:
                messagebox.showerror("Missing Dates", "Start and End dates are required.", parent=self); return
            if start_dt > end_dt:
                messagebox.showerror("Invalid Dates", "Start date cannot be after end date.", parent=self); return
        except ValueError:
            messagebox.showerror("Invalid Date Format", "Please use YYYY-MM-DD for dates.", parent=self); return

        selected_student_ids = [self.student_id_map_for_dialog[self.student_listbox.get(i)] for i in self.student_listbox.curselection()]
        if not selected_student_ids:
            messagebox.showwarning("No Students Selected", "Please select at least one student for the report.", parent=self); return

        self.result = (start_dt, end_dt, selected_student_ids)

class ConditionalFormattingRuleDialog(simpledialog.Dialog):
    def __init__(self, parent, app, rule_to_edit=None):
        self.app = app
        self.rule = rule_to_edit or {} # Existing rule or new empty dict
        self.result = None
        title = "Edit Conditional Formatting Rule" if rule_to_edit else "Add Conditional Formatting Rule"
        super().__init__(parent, title)

    def body(self, master):
        frame = ttk.Frame(master); frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # Rule Type
        ttk.Label(frame, text="Rule applies to:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=3)
        self.rule_type_var = tk.StringVar(value=self.rule.get("type", "group"))
        type_options = ["group", "behavior_count", "quiz_score_threshold"] # Add more types later
        self.type_combo = ttk.Combobox(frame, textvariable=self.rule_type_var, values=type_options, state="readonly", width=25)
        self.type_combo.grid(row=0, column=1, columnspan=2, padx=5, pady=3, sticky=tk.EW)
        self.type_combo.bind("<<ComboboxSelected>>", self.on_rule_type_change)

        # Condition Frame (changes based on rule_type)
        self.condition_frame = ttk.Frame(frame)
        self.condition_frame.grid(row=1, column=0, columnspan=3, pady=5, sticky=tk.NSEW)

        # Formatting Options
        format_frame = ttk.LabelFrame(frame, text="Formatting Actions");
        format_frame.grid(row=2, column=0, columnspan=3, pady=10, sticky=tk.EW)

        ttk.Label(format_frame, text="Set Box Fill Color:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=3)
        self.fill_color_var = tk.StringVar(value=self.rule.get("color", ""))
        self.fill_color_entry = ttk.Entry(format_frame, textvariable=self.fill_color_var, width=12)
        self.fill_color_entry.grid(row=0, column=1, padx=2, pady=3)
        ttk.Button(format_frame, text="Choose...", command=lambda: self.choose_color_for_var(self.fill_color_var)).grid(row=0, column=2, padx=2, pady=3)
        ttk.Button(format_frame, text="Clear", command=lambda: self.fill_color_var.set("")).grid(row=0, column=3, padx=2, pady=3)


        ttk.Label(format_frame, text="Set Box Outline Color:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=3)
        self.outline_color_var = tk.StringVar(value=self.rule.get("outline", ""))
        self.outline_color_entry = ttk.Entry(format_frame, textvariable=self.outline_color_var, width=12)
        self.outline_color_entry.grid(row=1, column=1, padx=2, pady=3)
        ttk.Button(format_frame, text="Choose...", command=lambda: self.choose_color_for_var(self.outline_color_var)).grid(row=1, column=2, padx=2, pady=3)
        ttk.Button(format_frame, text="Clear", command=lambda: self.outline_color_var.set("")).grid(row=1, column=3, padx=2, pady=3)

        # Initialize condition frame based on current/default rule type
        self.on_rule_type_change(None)
        return self.type_combo

    def choose_color_for_var(self, color_var):
        initial = color_var.get() if color_var.get() else None
        color_code = colorchooser.askcolor(title="Choose color", initialcolor=initial, parent=self)
        if color_code and color_code[1]: color_var.set(color_code[1])

    def on_rule_type_change(self, event):
        for widget in self.condition_frame.winfo_children(): widget.destroy() # Clear previous condition widgets
        rule_type = self.rule_type_var.get()

        if rule_type == "group":
            ttk.Label(self.condition_frame, text="Select Group:").pack(side=tk.LEFT, padx=5)
            self.group_var = tk.StringVar(value=self.rule.get("group_id", ""))
            group_names = {gid: gdata["name"] for gid, gdata in self.app.student_groups.items()}
            self.group_id_map_cond = {name: gid for gid, name in group_names.items()} # name to id
            self.group_combo_cond = ttk.Combobox(self.condition_frame, textvariable=self.group_var,
                                            values=[""] + sorted(group_names.values()), state="readonly", width=20)
            if self.rule.get("group_id") and self.rule["group_id"] in self.app.student_groups:
                 self.group_var.set(self.app.student_groups[self.rule["group_id"]]["name"])
            self.group_combo_cond.pack(side=tk.LEFT, padx=5)

        elif rule_type == "behavior_count":
            ttk.Label(self.condition_frame, text="Behavior:").pack(side=tk.LEFT, padx=5)
            self.behavior_name_var = tk.StringVar(value=self.rule.get("behavior_name", ""))
            self.behavior_combo_cond = ttk.Combobox(self.condition_frame, textvariable=self.behavior_name_var,
                                               values=[""] + self.app.all_behaviors, width=18)
            self.behavior_combo_cond.pack(side=tk.LEFT, padx=2)

            ttk.Label(self.condition_frame, text="Count >=:").pack(side=tk.LEFT, padx=5)
            self.behavior_count_var = tk.IntVar(value=self.rule.get("count_threshold", 1))
            ttk.Spinbox(self.condition_frame, from_=1, to=100, textvariable=self.behavior_count_var, width=4).pack(side=tk.LEFT, padx=2)

            ttk.Label(self.condition_frame, text="In Last (Hours):").pack(side=tk.LEFT, padx=5)
            self.behavior_hours_var = tk.IntVar(value=self.rule.get("time_window_hours", 24))
            ttk.Spinbox(self.condition_frame, from_=1, to=720, textvariable=self.behavior_hours_var, width=4).pack(side=tk.LEFT, padx=2)

        elif rule_type == "quiz_score_threshold":
            ttk.Label(self.condition_frame, text="Quiz Name (contains):").pack(side=tk.LEFT, padx=5)
            self.quiz_name_contains_var = tk.StringVar(value=self.rule.get("quiz_name_contains", ""))
            ttk.Entry(self.condition_frame, textvariable=self.quiz_name_contains_var, width=15).pack(side=tk.LEFT, padx=2)

            ttk.Label(self.condition_frame, text="Score (%):").pack(side=tk.LEFT, padx=5)
            self.quiz_op_var = tk.StringVar(value=self.rule.get("operator", "<="))
            ttk.Combobox(self.condition_frame, textvariable=self.quiz_op_var, values=["<=", ">=", "==", "<", ">"], width=3, state="readonly").pack(side=tk.LEFT, padx=2)
            self.quiz_score_thresh_var = tk.DoubleVar(value=self.rule.get("score_threshold_percent", 50.0))
            ttk.Spinbox(self.condition_frame, from_=0, to=100, increment=1, textvariable=self.quiz_score_thresh_var, width=5).pack(side=tk.LEFT, padx=2)


    def apply(self):
        final_rule = {"type": self.rule_type_var.get()}
        rule_type = final_rule["type"]

        fill = self.fill_color_var.get().strip()
        outline = self.outline_color_var.get().strip()
        if not fill and not outline:
            messagebox.showerror("No Action", "Please specify at least one formatting action (fill or outline color).", parent=self)
            return
        if fill: final_rule["color"] = fill
        if outline: final_rule["outline"] = outline

        if rule_type == "group":
            selected_group_name = self.group_var.get()
            if not selected_group_name: messagebox.showerror("Missing Info", "Please select a group.", parent=self); return
            final_rule["group_id"] = self.group_id_map_cond.get(selected_group_name)
            if not final_rule["group_id"]: messagebox.showerror("Error", "Selected group not found.", parent=self); return

        elif rule_type == "behavior_count":
            b_name = self.behavior_name_var.get().strip()
            if not b_name: messagebox.showerror("Missing Info", "Please select a behavior.", parent=self); return
            final_rule["behavior_name"] = b_name
            final_rule["count_threshold"] = self.behavior_count_var.get()
            final_rule["time_window_hours"] = self.behavior_hours_var.get()

        elif rule_type == "quiz_score_threshold":
            final_rule["quiz_name_contains"] = self.quiz_name_contains_var.get().strip() # Can be empty for any quiz
            final_rule["operator"] = self.quiz_op_var.get()
            final_rule["score_threshold_percent"] = self.quiz_score_thresh_var.get()
        
        self.result = final_rule

class ManageStudentGroupsDialog(simpledialog.Dialog):
    def __init__(self, parent, student_groups_data, students_data, app, default_colors):
        self.student_groups = student_groups_data # This is a reference to app.student_groups, modified directly
        self.students = students_data # App.students, for assigning
        self.app = app # To get new group ID, and redraw
        self.default_colors = default_colors
        self.groups_changed_flag = False # Set to True if any persistent change is made
        super().__init__(parent, "Manage Student Groups")

    def body(self, master):
        self.master_frame = master
        top_frame = ttk.Frame(master); top_frame.pack(pady=5, padx=5, fill=tk.X)
        ttk.Button(top_frame, text="Add New Group", command=self.add_group).pack(side=tk.LEFT, padx=5)

        self.canvas_groups = tk.Canvas(master, borderwidth=0, background="#ffffff")
        self.groups_scrollable_frame = ttk.Frame(self.canvas_groups)
        self.scrollbar_groups = ttk.Scrollbar(master, orient="vertical", command=self.canvas_groups.yview)
        self.canvas_groups.configure(yscrollcommand=self.scrollbar_groups.set)

        self.scrollbar_groups.pack(side="right", fill="y")
        self.canvas_groups.pack(side="left", fill="both", expand=True)
        self.canvas_groups_window = self.canvas_groups.create_window((0,0), window=self.groups_scrollable_frame, anchor="nw")

        self.groups_scrollable_frame.bind("<Configure>", lambda e: self.canvas_groups.configure(scrollregion=self.canvas_groups.bbox("all")))
        self.canvas_groups.bind('<MouseWheel>', self._on_mousewheel_groups)

        self.populate_groups_list()
        return self.groups_scrollable_frame # For initial focus target (though dynamic)

    def _on_mousewheel_groups(self, event):
        if event.delta: self.canvas_groups.yview_scroll(int(-1*(event.delta/120)), "units")
        else: self.canvas_groups.yview_scroll(1 if event.num == 5 else -1, "units")


    def populate_groups_list(self):
        for widget in self.groups_scrollable_frame.winfo_children(): widget.destroy()
        row_idx = 0
        if not self.student_groups:
            ttk.Label(self.groups_scrollable_frame, text="No groups created yet.").pack(pady=10)
            return

        sorted_groups = sorted(self.student_groups.items(), key=lambda item: item[1]['name'])

        for group_id, group_data in sorted_groups:
            group_frame = ttk.Frame(self.groups_scrollable_frame, padding=5, relief=tk.RIDGE, borderwidth=1)
            group_frame.pack(fill=tk.X, pady=3, padx=3)

            name_var = tk.StringVar(value=group_data["name"])
            color_var = tk.StringVar(value=group_data.get("color", self.default_colors[0]))

            ttk.Label(group_frame, text="Name:").grid(row=0, column=0, sticky=tk.W)
            name_entry = ttk.Entry(group_frame, textvariable=name_var, width=20)
            name_entry.grid(row=0, column=1, padx=3)
            name_entry.bind("<FocusOut>", lambda e, gid=group_id, nv=name_var: self.update_group_name(gid, nv.get()))

            ttk.Label(group_frame, text="Color:").grid(row=0, column=2, sticky=tk.W, padx=(10,0))
            color_entry = ttk.Entry(group_frame, textvariable=color_var, width=10)
            color_entry.grid(row=0, column=3, padx=3)
            color_btn = ttk.Button(group_frame, text="...", width=3, command=lambda cv=color_var, gid=group_id: self.choose_group_color(cv, gid))
            color_btn.grid(row=0, column=4)
            color_preview = tk.Label(group_frame, text="  ", bg=color_var.get(), width=2, relief=tk.SUNKEN)
            color_preview.grid(row=0, column=5, padx=2)
            color_var.trace_add("write", lambda *args, cp=color_preview, cv=color_var: cp.config(bg=cv.get()))


            ttk.Button(group_frame, text="Assign Students...", command=lambda gid=group_id, gname=group_data["name"]: self.assign_students_to_group_dialog(gid, gname)).grid(row=0, column=6, padx=5)
            ttk.Button(group_frame, text="Delete Group", command=lambda gid=group_id: self.delete_group(gid)).grid(row=0, column=7, padx=5)

            # Show number of students in group
            count = sum(1 for sid, sdata in self.students.items() if sdata.get("group_id") == group_id)
            ttk.Label(group_frame, text=f"({count} student{'s' if count !=1 else ''})").grid(row=0, column=8, padx=5, sticky=tk.E)
            group_frame.grid_columnconfigure(8, weight=1) # Push delete button to right a bit


    def add_group(self):
        new_group_name = simpledialog.askstring("New Group", "Enter name for the new group:", parent=self)
        if new_group_name and new_group_name.strip():
            group_id_str, next_id_val = self.app.get_new_group_id() # Get ID from app
            # Check for name collision BEFORE updating app's next_group_id_num state
            if any(g['name'].lower() == new_group_name.strip().lower() for g in self.student_groups.values()):
                 messagebox.showwarning("Duplicate Name", f"A group named '{new_group_name.strip()}' already exists.", parent=self)
                 return # Do not consume the ID from app if name is duplicate

            self.app.next_group_id_num = next_id_val # Commit ID usage
            new_color_index = (self.app.next_group_id_num -1) % len(self.default_colors) # Cycle through default colors
            self.student_groups[group_id_str] = {"name": new_group_name.strip(), "color": self.default_colors[new_color_index]}
            self.groups_changed_flag = True
            self.populate_groups_list()
        elif new_group_name is not None: # User entered empty string
             messagebox.showwarning("Invalid Name", "Group name cannot be empty.", parent=self)


    def update_group_name(self, group_id, new_name):
        new_name = new_name.strip()
        if not new_name:
            messagebox.showwarning("Invalid Name", "Group name cannot be empty. Reverting.", parent=self)
            self.populate_groups_list(); return # Revert by repopulating
        
        # Check for name collision with OTHER groups
        if any(g_id != group_id and g_data['name'].lower() == new_name.lower() for g_id, g_data in self.student_groups.items()):
            messagebox.showwarning("Duplicate Name", f"Another group named '{new_name}' already exists. Reverting.", parent=self)
            self.populate_groups_list(); return

        if self.student_groups[group_id]["name"] != new_name:
            self.student_groups[group_id]["name"] = new_name
            self.groups_changed_flag = True
            # No need to repopulate for just name change if var is linked, but good for consistency if other things change
            self.populate_groups_list() # Repopulate to reflect changes and resort


    def choose_group_color(self, color_var, group_id):
        initial_color = color_var.get()
        new_color = colorchooser.askcolor(initial_color, title=f"Choose color for group", parent=self)
        if new_color and new_color[1]:
            if self.student_groups[group_id].get("color") != new_color[1]:
                color_var.set(new_color[1]) # This will trigger trace and update preview
                self.student_groups[group_id]["color"] = new_color[1]
                self.groups_changed_flag = True
                # No repopulate needed just for color if var is traced.

    def delete_group(self, group_id):
        group_name = self.student_groups[group_id]["name"]
        if messagebox.askyesno("Confirm Delete", f"Are you sure you want to delete group '{group_name}'?\nStudents in this group will be unassigned.", parent=self):
            # Unassign students from this group
            for student_id, student_data in self.students.items():
                if student_data.get("group_id") == group_id:
                    student_data["group_id"] = None # Or del student_data["group_id"]
            del self.student_groups[group_id]
            self.groups_changed_flag = True
            self.populate_groups_list()

    def assign_students_to_group_dialog(self, group_id, group_name):
        dialog = AssignStudentsToGroupSubDialog(self, group_id, group_name, self.students, self.student_groups)
        if dialog.assignments_changed:
            self.groups_changed_flag = True # Signal main app that changes occurred
            self.populate_groups_list() # Repopulate to update student counts

    def apply(self): # Called when OK is pressed
        # Changes are applied directly, so just set the flag if it was ever true
        self.result = self.groups_changed_flag
        if self.groups_changed_flag:
            self.app.draw_all_items(check_collisions_on_redraw=True) # Redraw if groups changed
            self.app.save_student_groups() # Save groups if changed

class AssignStudentsToGroupSubDialog(simpledialog.Dialog):
    def __init__(self, parent_dialog, group_id, group_name, all_students_data, all_groups_data):
        self.parent_dialog_ref = parent_dialog # Reference to ManageStudentGroupsDialog
        self.group_id_to_assign = group_id
        self.group_name = group_name
        self.all_students = all_students_data # app.students
        self.all_groups = all_groups_data # app.student_groups
        self.assignments_changed = False
        super().__init__(parent_dialog, f"Assign Students to '{group_name}'")

    def body(self, master):
        # Listbox for available students (not in any group OR in a different group)
        # Listbox for students currently in THIS group
        frame = ttk.Frame(master); frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        
        available_frame = ttk.LabelFrame(frame, text="Available Students"); available_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        self.available_lb = tk.Listbox(available_frame, selectmode=tk.EXTENDED, exportselection=False, height=15)
        self.available_lb.pack(fill=tk.BOTH, expand=True, pady=2)
        self.available_students_map = {} # display name -> student_id

        buttons_frame = ttk.Frame(frame); buttons_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5)
        ttk.Button(buttons_frame, text=">> Add >>", command=self.add_to_group).pack(pady=10)
        ttk.Button(buttons_frame, text="<< Remove <<", command=self.remove_from_group).pack(pady=10)

        assigned_frame = ttk.LabelFrame(frame, text=f"Students in '{self.group_name}'"); assigned_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        self.assigned_lb = tk.Listbox(assigned_frame, selectmode=tk.EXTENDED, exportselection=False, height=15)
        self.assigned_lb.pack(fill=tk.BOTH, expand=True, pady=2)
        self.assigned_students_map = {} # display name -> student_id

        self.populate_student_lists()
        return self.available_lb

    def populate_student_lists(self):
        self.available_lb.delete(0, tk.END); self.assigned_lb.delete(0, tk.END)
        self.available_students_map.clear(); self.assigned_students_map.clear()

        sorted_all_students = sorted(self.all_students.values(), key=lambda s: (s['last_name'], s['first_name']))

        for s_data in sorted_all_students:
            s_id = s_data["id"]
            display_name = f"{s_data['last_name']}, {s_data['first_name']}" + (f" ({s_data.get('nickname')})" if s_data.get('nickname') else "")
            
            if s_data.get("group_id") == self.group_id_to_assign:
                self.assigned_lb.insert(tk.END, display_name)
                self.assigned_students_map[display_name] = s_id
            elif not s_data.get("group_id") or s_data.get("group_id") == "NONE_GROUP_SENTINEL": # Truly unassigned
                self.available_lb.insert(tk.END, display_name)
                self.available_students_map[display_name] = s_id
            # Else: student is in a *different* group, don't show in "Available" unless we want a "move from group X" feature

    def add_to_group(self):
        selected_indices = self.available_lb.curselection()
        if not selected_indices: return
        for i in reversed(selected_indices): # Iterate reversed to handle index changes on delete
            display_name = self.available_lb.get(i)
            student_id = self.available_students_map.get(display_name)
            if student_id and student_id in self.all_students:
                self.all_students[student_id]["group_id"] = self.group_id_to_assign
                self.assignments_changed = True
        self.populate_student_lists() # Refresh both listboxes

    def remove_from_group(self):
        selected_indices = self.assigned_lb.curselection()
        if not selected_indices: return
        for i in reversed(selected_indices):
            display_name = self.assigned_lb.get(i)
            student_id = self.assigned_students_map.get(display_name)
            if student_id and student_id in self.all_students:
                self.all_students[student_id]["group_id"] = None # Unassign
                self.assignments_changed = True
        self.populate_student_lists()

    def apply(self):
        # Changes were made directly to self.all_students (app.students)
        # The self.assignments_changed flag will be checked by the parent dialog
        pass
# --- Quiz Template Management ---
class ManageQuizTemplatesDialog(simpledialog.Dialog):
    def __init__(self, parent, app_instance):
        self.app = app_instance # Main application instance
        self.templates_changed_flag = False
        super().__init__(parent, "Manage Quiz Templates")

    def body(self, master):
        self.master_frame = master
        top_frame = ttk.Frame(master); top_frame.pack(pady=5, padx=5, fill=tk.X)
        ttk.Button(top_frame, text="Add New Quiz Template", command=self.add_template).pack(side=tk.LEFT, padx=5)

        self.canvas_templates = tk.Canvas(master, borderwidth=0, background="#ffffff")
        self.templates_scrollable_frame = ttk.Frame(self.canvas_templates)
        self.scrollbar_templates = ttk.Scrollbar(master, orient="vertical", command=self.canvas_templates.yview)
        self.canvas_templates.configure(yscrollcommand=self.scrollbar_templates.set)

        self.scrollbar_templates.pack(side="right", fill="y")
        self.canvas_templates.pack(side="left", fill="both", expand=True)
        self.canvas_templates.create_window((0,0), window=self.templates_scrollable_frame, anchor="nw", tags="self.templates_scrollable_frame")

        self.templates_scrollable_frame.bind("<Configure>", lambda e: self.canvas_templates.configure(scrollregion=self.canvas_templates.bbox("all")))
        self.canvas_templates.bind('<MouseWheel>', self._on_mousewheel_templates)
        
        self.populate_templates_list()
        return self.templates_scrollable_frame

    def _on_mousewheel_templates(self, event):
        if event.delta: self.canvas_templates.yview_scroll(int(-1*(event.delta/120)), "units")
        else: self.canvas_templates.yview_scroll(1 if event.num == 5 else -1, "units")

    def populate_templates_list(self):
        for widget in self.templates_scrollable_frame.winfo_children(): widget.destroy()
        if not self.app.quiz_templates:
            ttk.Label(self.templates_scrollable_frame, text="No quiz templates created yet.").pack(pady=10)
            return

        sorted_templates = sorted(self.app.quiz_templates.items(), key=lambda item: item[1]['name'])
        for tpl_id, tpl_data in sorted_templates:
            tpl_frame = ttk.Frame(self.templates_scrollable_frame, padding=5, relief=tk.RIDGE, borderwidth=1)
            tpl_frame.pack(fill=tk.X, pady=3, padx=3)
            
            summary = f"{tpl_data['name']} ({tpl_data.get('num_questions', 'N/A')} Qs)"
            ttk.Label(tpl_frame, text=summary, width=40, anchor=tk.W).pack(side=tk.LEFT, padx=5)
            ttk.Button(tpl_frame, text="Edit", command=lambda tid=tpl_id: self.edit_template(tid)).pack(side=tk.LEFT, padx=3)
            ttk.Button(tpl_frame, text="Delete", command=lambda tid=tpl_id: self.delete_template(tid)).pack(side=tk.LEFT, padx=3)

    def add_template(self):
        dialog = QuizTemplateEditDialog(self, self.app, template_data=None) # Pass self as parent
        if dialog.result_template_data:
            template_id_str, next_id_val = self.app.get_new_quiz_template_id()
            
            # Check for name collision BEFORE committing ID
            if any(t['name'].lower() == dialog.result_template_data['name'].lower() for t in self.app.quiz_templates.values()):
                messagebox.showwarning("Duplicate Name", f"A quiz template named '{dialog.result_template_data['name']}' already exists.", parent=self)
                return
            
            self.app.next_quiz_template_id_num = next_id_val # Commit ID usage
            self.app.quiz_templates[template_id_str] = dialog.result_template_data
            self.templates_changed_flag = True
            self.populate_templates_list()

    def edit_template(self, template_id):
        if template_id not in self.app.quiz_templates: return
        current_template_data = self.app.quiz_templates[template_id]
        dialog = QuizTemplateEditDialog(self, self.app, template_data=current_template_data.copy(), existing_template_id=template_id)
        if dialog.result_template_data:
            # Check for name collision with OTHER templates
            if any(tid != template_id and t_data['name'].lower() == dialog.result_template_data['name'].lower() for tid, t_data in self.app.quiz_templates.items()):
                 messagebox.showwarning("Duplicate Name", f"Another quiz template named '{dialog.result_template_data['name']}' already exists. Edit cancelled.", parent=self)
                 return

            self.app.quiz_templates[template_id] = dialog.result_template_data
            self.templates_changed_flag = True
            self.populate_templates_list()

    def delete_template(self, template_id):
        if template_id not in self.app.quiz_templates: return
        tpl_name = self.app.quiz_templates[template_id]["name"]
        if messagebox.askyesno("Confirm Delete", f"Delete quiz template '{tpl_name}'?", parent=self):
            del self.app.quiz_templates[template_id]
            self.templates_changed_flag = True
            self.populate_templates_list()

    def apply(self): # OK button
        self.result = self.templates_changed_flag


class QuizTemplateEditDialog(simpledialog.Dialog):
    def __init__(self, parent_dialog, app_instance, template_data=None, existing_template_id=None):
        self.app = app_instance
        self.template_data_initial = template_data or {} # If editing, this is a copy
        self.existing_template_id = existing_template_id # Used to avoid name collision with self
        self.result_template_data = None # Populated on successful apply
        self.mark_entry_vars_tpl = {} # {mark_type_id: StringVar}
        title = "Edit Quiz Template" if template_data else "Add New Quiz Template"
        super().__init__(parent_dialog, title)

    def body(self, master):
        main_frame = ttk.Frame(master); main_frame.pack(padx=10, pady=10, expand=True, fill=tk.BOTH)
        
        name_frame = ttk.Frame(main_frame); name_frame.pack(fill=tk.X, pady=3)
        ttk.Label(name_frame, text="Template Name:").pack(side=tk.LEFT, padx=5)
        self.tpl_name_var = tk.StringVar(value=self.template_data_initial.get("name", ""))
        self.tpl_name_entry = ttk.Entry(name_frame, textvariable=self.tpl_name_var, width=35)
        self.tpl_name_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)

        num_q_frame = ttk.Frame(main_frame); num_q_frame.pack(fill=tk.X, pady=3)
        ttk.Label(num_q_frame, text="Number of Questions:").pack(side=tk.LEFT, padx=5)
        self.tpl_num_q_var = tk.StringVar(value=str(self.template_data_initial.get("num_questions", self.app.settings.get("default_quiz_questions",10))))
        self.tpl_num_q_spinbox = ttk.Spinbox(num_q_frame, from_=1, to=200, textvariable=self.tpl_num_q_var, width=5)
        self.tpl_num_q_spinbox.pack(side=tk.LEFT, padx=5)

        marks_frame = ttk.LabelFrame(main_frame, text="Default Marks (per question, if applicable)"); marks_frame.pack(pady=5, fill=tk.BOTH, expand=True)
        cols = 2
        current_col, current_row = 0,0
        default_marks_initial = self.template_data_initial.get("default_marks", {})
        for mt in self.app.settings.get("quiz_mark_types", []):
            mt_id = mt["id"]; mt_name = mt["name"]
            ttk.Label(marks_frame, text=f"{mt_name}:").grid(row=current_row, column=current_col*2, sticky=tk.W, padx=5, pady=2)
            var = tk.StringVar(value=str(default_marks_initial.get(mt_id, ""))) # "" if not set, or default_points
            self.mark_entry_vars_tpl[mt_id] = var
            entry = ttk.Entry(marks_frame, textvariable=var, width=8)
            entry.grid(row=current_row, column=current_col*2 + 1, sticky=tk.EW, padx=5, pady=2)
            current_col += 1
            if current_col >= cols: current_col = 0; current_row += 1
        for i in range(cols*2): marks_frame.grid_columnconfigure(i, weight=1 if i%2==1 else 0)
        
        return self.tpl_name_entry # Initial focus

    def apply(self):
        name = self.tpl_name_var.get().strip()
        if not name: messagebox.showerror("Input Required", "Template name cannot be empty.", parent=self); return
        try: num_q = int(self.tpl_num_q_var.get())
        except ValueError: messagebox.showerror("Invalid Input", "Number of questions must be an integer.", parent=self); return
        if num_q <=0: messagebox.showerror("Invalid Input", "Number of questions must be positive.", parent=self); return
        
        default_marks = {}
        for mt_id, var in self.mark_entry_vars_tpl.items():
            val_str = var.get().strip()
            if val_str: # Only store if set
                try: default_marks[mt_id] = int(val_str) # Store as int
                except ValueError: messagebox.showerror("Invalid Mark", f"Default mark for '{mt_id}' must be an integer or empty.", parent=self); return
        
        self.result_template_data = {"name": name, "num_questions": num_q, "default_marks": default_marks}

# --- Homework Template Management (New) ---
class ManageHomeworkTemplatesDialog(simpledialog.Dialog):
    def __init__(self, parent, app_instance):
        self.app = app_instance
        self.templates_changed_flag = False
        super().__init__(parent, "Manage Homework Templates")

    def body(self, master):
        self.master_frame = master
        top_frame = ttk.Frame(master); top_frame.pack(pady=5, padx=5, fill=tk.X)
        ttk.Button(top_frame, text="Add New Homework Template", command=self.add_template).pack(side=tk.LEFT, padx=5)

        self.canvas_templates = tk.Canvas(master, borderwidth=0, background="#ffffff")
        self.templates_scrollable_frame = ttk.Frame(self.canvas_templates)
        self.scrollbar_templates = ttk.Scrollbar(master, orient="vertical", command=self.canvas_templates.yview)
        self.canvas_templates.configure(yscrollcommand=self.scrollbar_templates.set)
        self.scrollbar_templates.pack(side="right", fill="y")
        self.canvas_templates.pack(side="left", fill="both", expand=True)
        self.canvas_templates.create_window((0,0), window=self.templates_scrollable_frame, anchor="nw", tags="self.templates_scrollable_frame")
        self.templates_scrollable_frame.bind("<Configure>", lambda e: self.canvas_templates.configure(scrollregion=self.canvas_templates.bbox("all")))
        self.canvas_templates.bind('<MouseWheel>', self._on_mousewheel_templates)
        self.populate_templates_list()
        return self.templates_scrollable_frame

    def _on_mousewheel_templates(self, event):
        if event.delta: self.canvas_templates.yview_scroll(int(-1*(event.delta/120)), "units")
        else: self.canvas_templates.yview_scroll(1 if event.num == 5 else -1, "units")

    def populate_templates_list(self):
        for widget in self.templates_scrollable_frame.winfo_children(): widget.destroy()
        if not self.app.homework_templates:
            ttk.Label(self.templates_scrollable_frame, text="No homework templates created yet.").pack(pady=10)
            return
        sorted_templates = sorted(self.app.homework_templates.items(), key=lambda item: item[1]['name'])
        for tpl_id, tpl_data in sorted_templates:
            tpl_frame = ttk.Frame(self.templates_scrollable_frame, padding=5, relief=tk.RIDGE, borderwidth=1)
            tpl_frame.pack(fill=tk.X, pady=3, padx=3)
            summary = f"{tpl_data['name']} ({tpl_data.get('num_items', 'N/A')} items)"
            ttk.Label(tpl_frame, text=summary, width=40, anchor=tk.W).pack(side=tk.LEFT, padx=5)
            ttk.Button(tpl_frame, text="Edit", command=lambda tid=tpl_id: self.edit_template(tid)).pack(side=tk.LEFT, padx=3)
            ttk.Button(tpl_frame, text="Delete", command=lambda tid=tpl_id: self.delete_template(tid)).pack(side=tk.LEFT, padx=3)

    def add_template(self):
        dialog = HomeworkTemplateEditDialog(self, self.app, template_data=None)
        if dialog.result_template_data:
            template_id_str, next_id_val = self.app.get_new_homework_template_id()
            if any(t['name'].lower() == dialog.result_template_data['name'].lower() for t in self.app.homework_templates.values()):
                messagebox.showwarning("Duplicate Name", f"A homework template named '{dialog.result_template_data['name']}' already exists.", parent=self)
                return
            self.app.next_homework_template_id_num = next_id_val
            self.app.homework_templates[template_id_str] = dialog.result_template_data
            self.templates_changed_flag = True
            self.populate_templates_list()

    def edit_template(self, template_id):
        if template_id not in self.app.homework_templates: return
        current_template_data = self.app.homework_templates[template_id]
        dialog = HomeworkTemplateEditDialog(self, self.app, template_data=current_template_data.copy(), existing_template_id=template_id)
        if dialog.result_template_data:
            if any(tid != template_id and t_data['name'].lower() == dialog.result_template_data['name'].lower() for tid, t_data in self.app.homework_templates.items()):
                 messagebox.showwarning("Duplicate Name", f"Another homework template named '{dialog.result_template_data['name']}' already exists. Edit cancelled.", parent=self)
                 return
            self.app.homework_templates[template_id] = dialog.result_template_data
            self.templates_changed_flag = True
            self.populate_templates_list()

    def delete_template(self, template_id):
        if template_id not in self.app.homework_templates: return
        tpl_name = self.app.homework_templates[template_id]["name"]
        if messagebox.askyesno("Confirm Delete", f"Delete homework template '{tpl_name}'?", parent=self):
            del self.app.homework_templates[template_id]
            self.templates_changed_flag = True
            self.populate_templates_list()

    def apply(self):
        self.result = self.templates_changed_flag


class HomeworkTemplateEditDialog(simpledialog.Dialog):
    def __init__(self, parent_dialog, app_instance, template_data=None, existing_template_id=None):
        self.app = app_instance
        self.template_data_initial = template_data or {}
        self.existing_template_id = existing_template_id
        self.result_template_data = None
        self.mark_entry_vars_hw_tpl = {} # {homework_mark_type_id: StringVar}
        title = "Edit Homework Template" if template_data else "Add New Homework Template"
        super().__init__(parent_dialog, title)

    def body(self, master):
        main_frame = ttk.Frame(master); main_frame.pack(padx=10, pady=10, expand=True, fill=tk.BOTH)
        name_frame = ttk.Frame(main_frame); name_frame.pack(fill=tk.X, pady=3)
        ttk.Label(name_frame, text="Template Name:").pack(side=tk.LEFT, padx=5)
        self.tpl_name_var = tk.StringVar(value=self.template_data_initial.get("name", ""))
        self.tpl_name_entry = ttk.Entry(name_frame, textvariable=self.tpl_name_var, width=35)
        self.tpl_name_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)

        num_items_frame = ttk.Frame(main_frame); num_items_frame.pack(fill=tk.X, pady=3)
        ttk.Label(num_items_frame, text="Number of Items/Tasks:").pack(side=tk.LEFT, padx=5)
        self.tpl_num_items_var = tk.StringVar(value=str(self.template_data_initial.get("num_items", 10))) # Default if not set
        self.tpl_num_items_spinbox = ttk.Spinbox(num_items_frame, from_=0, to=200, textvariable=self.tpl_num_items_var, width=5) # 0 if not applicable
        self.tpl_num_items_spinbox.pack(side=tk.LEFT, padx=5)

        marks_frame = ttk.LabelFrame(main_frame, text="Default Marks/Statuses"); marks_frame.pack(pady=5, fill=tk.BOTH, expand=True)
        cols = 2
        current_col, current_row = 0,0
        default_marks_initial = self.template_data_initial.get("default_marks", {})
        for hmt in self.app.settings.get("homework_mark_types", []):
            hmt_id = hmt["id"]; hmt_name = hmt["name"]
            ttk.Label(marks_frame, text=f"{hmt_name}:").grid(row=current_row, column=current_col*2, sticky=tk.W, padx=5, pady=2)
            var = tk.StringVar(value=str(default_marks_initial.get(hmt_id, ""))) # "" or default_points
            self.mark_entry_vars_hw_tpl[hmt_id] = var
            entry = ttk.Entry(marks_frame, textvariable=var, width=10) # Wider for potential text status
            entry.grid(row=current_row, column=current_col*2 + 1, sticky=tk.EW, padx=5, pady=2)
            current_col += 1
            if current_col >= cols: current_col = 0; current_row += 1
        for i in range(cols*2): marks_frame.grid_columnconfigure(i, weight=1 if i%2==1 else 0)
        return self.tpl_name_entry

    def apply(self):
        name = self.tpl_name_var.get().strip()
        if not name: messagebox.showerror("Input Required", "Template name cannot be empty.", parent=self); return
        try: num_items = int(self.tpl_num_items_var.get())
        except ValueError: messagebox.showerror("Invalid Input", "Number of items must be an integer (or 0 if not applicable).", parent=self); return
        if num_items < 0: messagebox.showerror("Invalid Input", "Number of items cannot be negative.", parent=self); return
        
        default_marks = {}
        for hmt_id, var in self.mark_entry_vars_hw_tpl.items():
            val_str = var.get().strip()
            if val_str: # Only store if set
                # Try to convert to float/int if numeric, else store as string (for statuses like "Done")
                try: default_marks[hmt_id] = float(val_str)
                except ValueError: default_marks[hmt_id] = val_str # Store as string if not purely numeric
        
        self.result_template_data = {"name": name, "num_items": num_items, "default_marks": default_marks}

class ManageInitialsDialog(simpledialog.Dialog):
    def __init__(self, parent, initials_overrides_dict, all_names_list, item_type_display_name):
        self.initials_overrides = initials_overrides_dict # Direct reference to app.settings[key]
        self.all_names = sorted(list(set(all_names_list)))
        self.item_type_name = item_type_display_name # e.g., "Behavior/Quiz" or "Homework Log"
        self.initials_changed = False
        self.entry_vars = {} # name -> StringVar
        super().__init__(parent, f"Manage Initials for {self.item_type_name}")

    def body(self, master):
        info_label = ttk.Label(master, text=f"Set custom initials for {self.item_type_name} types.\nLeave blank to use auto-generated initials.", justify=tk.LEFT)
        info_label.pack(pady=5, padx=5, anchor=tk.W)
        
        canvas_frame = ttk.Frame(master); canvas_frame.pack(fill=tk.BOTH, expand=True)
        self.canvas_initials = tk.Canvas(canvas_frame, borderwidth=0)
        scrollable_content_frame = ttk.Frame(self.canvas_initials)
        scrollbar = ttk.Scrollbar(canvas_frame, orient="vertical", command=self.canvas_initials.yview)
        self.canvas_initials.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y"); self.canvas_initials.pack(side="left", fill="both", expand=True)
        self.canvas_initials.create_window((0,0), window=scrollable_content_frame, anchor="nw")
        scrollable_content_frame.bind("<Configure>", lambda e: self.canvas_initials.configure(scrollregion=self.canvas_initials.bbox("all")))
        self.canvas_initials.bind('<MouseWheel>', lambda e: self.canvas_initials.yview_scroll(int(-1*(e.delta/120)), "units"))

        for name in self.all_names:
            item_frame = ttk.Frame(scrollable_content_frame); item_frame.pack(fill=tk.X, pady=1)
            ttk.Label(item_frame, text=name, width=30, anchor=tk.W).pack(side=tk.LEFT, padx=5)
            var = tk.StringVar(value=self.initials_overrides.get(name, ""))
            self.entry_vars[name] = var
            entry = ttk.Entry(item_frame, textvariable=var, width=5)
            entry.pack(side=tk.LEFT, padx=5)
        return canvas_frame # Or some specific entry if needed for focus

    def apply(self):
        for name, var in self.entry_vars.items():
            new_initial = var.get().strip()[:3] # Max 3 chars for initials
            if new_initial:
                if self.initials_overrides.get(name) != new_initial:
                    self.initials_overrides[name] = new_initial
                    self.initials_changed = True
            elif name in self.initials_overrides: # If blanked out and was set
                del self.initials_overrides[name]
                self.initials_changed = True
        # self.initials_overrides dictionary is modified directly.
        # self.initials_changed flag will be checked by SettingsDialog.


class ManageMarkTypesDialog(simpledialog.Dialog):
    def __init__(self, parent, current_mark_types_list, item_type_display_name, default_mark_types):
        self.mark_types_ref = current_mark_types_list # Direct reference, e.g., app.settings["quiz_mark_types"]
        self.item_type_name = item_type_display_name # "Quiz Mark Types" or "Homework Mark Types"
        self.default_mark_types_const = default_mark_types # The constant list for reset
        self.mark_types_changed = False
        super().__init__(parent, f"Manage {self.item_type_name}")

    def body(self, master):
        self.main_frame = master # To rebuild list
        button_frame = ttk.Frame(master); button_frame.pack(fill=tk.X, pady=5)
        ttk.Button(button_frame, text="Add New Mark Type", command=self.add_mark_type).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Reset to Defaults", command=self.reset_to_defaults).pack(side=tk.LEFT, padx=5)

        self.list_frame = ttk.Frame(master); self.list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        self.populate_mark_types_ui()
        return self.main_frame # For focus

    def populate_mark_types_ui(self):
        for widget in self.list_frame.winfo_children(): widget.destroy()
        
        headers = ["ID", "Name", "Default Points", "To Total?", "Bonus?"]
        for c, h_text in enumerate(headers):
            ttk.Label(self.list_frame, text=h_text, font=("",9,"bold")).grid(row=0,column=c,padx=3,pady=3,sticky=tk.W)

        self.mark_type_widgets = [] # Store refs to entry vars/widgets if needed for direct update
        
        for r_idx, mt_dict in enumerate(self.mark_types_ref, start=1):
            widgets_row = {}
            # ID (display only for defaults, editable for custom?) - For now, mostly fixed post-creation
            id_val = mt_dict.get("id", f"custom_{r_idx}")
            widgets_row["id_label"] = ttk.Label(self.list_frame, text=id_val, width=15); widgets_row["id_label"].grid(row=r_idx, column=0, padx=3, sticky=tk.W)
            
            # Name
            name_var = tk.StringVar(value=mt_dict.get("name","")); widgets_row["name_var"] = name_var
            name_entry = ttk.Entry(self.list_frame, textvariable=name_var, width=20); name_entry.grid(row=r_idx, column=1, padx=3, sticky=tk.EW)
            
            # Default Points
            points_var = tk.DoubleVar(value=mt_dict.get("default_points",0.0)); widgets_row["points_var"] = points_var
            points_spin = ttk.Spinbox(self.list_frame, from_=-100, to=100, increment=0.1, textvariable=points_var, width=6); points_spin.grid(row=r_idx, column=2, padx=3)

            # Contributes to Total (Bool)
            to_total_var = tk.BooleanVar(value=mt_dict.get("contributes_to_total",True)); widgets_row["to_total_var"] = to_total_var
            ttk.Checkbutton(self.list_frame, variable=to_total_var).grid(row=r_idx, column=3, padx=3)
            
            # Is Extra Credit (Bool)
            is_bonus_var = tk.BooleanVar(value=mt_dict.get("is_extra_credit",False)); widgets_row["is_bonus_var"] = is_bonus_var
            ttk.Checkbutton(self.list_frame, variable=is_bonus_var).grid(row=r_idx, column=4, padx=3)

            del_btn = ttk.Button(self.list_frame, text="X", command=lambda idx=r_idx-1: self.delete_mark_type_at_index(idx), width=3)
            del_btn.grid(row=r_idx, column=5, padx=3)
            self.mark_type_widgets.append(widgets_row) # Store the dict of vars/widgets for this row
        self.list_frame.grid_columnconfigure(1, weight=1) # Allow name entry to expand


    def add_mark_type(self):
        if len(self.mark_types_ref) >= MAX_CUSTOM_TYPES: # Or a specific limit for mark types
            messagebox.showwarning("Limit Reached", "Maximum number of mark types reached.", parent=self); return
        
        new_id_base = "custom_mark"
        new_id_suffix = 1
        while f"{new_id_base}_{new_id_suffix}" in (mt.get("id") for mt in self.mark_types_ref):
            new_id_suffix +=1
        
        new_mark = {
            "id": f"{new_id_base}_{new_id_suffix}", "name": "New Mark Type", "default_points": 0.0,
            "contributes_to_total": False, "is_extra_credit": False
        }
        self.mark_types_ref.append(new_mark)
        self.mark_types_changed = True
        self.populate_mark_types_ui()

    def delete_mark_type_at_index(self, index):
        if 0 <= index < len(self.mark_types_ref):
            # Check if it's a default one, prevent deletion (or handle carefully)
            # For now, allow deletion, user can reset to defaults
            if messagebox.askyesno("Confirm Delete", f"Delete mark type '{self.mark_types_ref[index]['name']}'?", parent=self):
                del self.mark_types_ref[index]
                self.mark_types_changed = True
                self.populate_mark_types_ui()
    
    def reset_to_defaults(self):
        if messagebox.askyesno("Confirm Reset", f"Reset all {self.item_type_name.lower()} to application defaults?", parent=self):
            self.mark_types_ref.clear()
            for default_item in self.default_mark_types_const:
                self.mark_types_ref.append(default_item.copy()) # Add copies
            self.mark_types_changed = True
            self.populate_mark_types_ui()

    def apply(self): # OK button
        # Update the list of dicts from the UI widgets
        updated_list = []
        for row_widgets in self.mark_type_widgets:
            # Get ID from label (it's not editable here, but needed for the dict)
            current_id = row_widgets["id_label"].cget("text")
            name = row_widgets["name_var"].get().strip()
            if not name:
                messagebox.showerror("Invalid Name", f"Mark type name for ID '{current_id}' cannot be empty.", parent=self)
                # To prevent dialog closing on error, simpledialog needs validate() to return false.
                # This is tricky here as apply() is called after validate().
                # For now, we'll allow it but it might lead to an empty name. Better: prevent empty.
                return # Or handle error state
            
            # Check for duplicate names before saving
            if any(item['name'] == name and item['id'] != current_id for item in updated_list):
                messagebox.showerror("Duplicate Name", f"Mark type name '{name}' is already used. Names must be unique.", parent=self)
                return

            updated_list.append({
                "id": current_id,
                "name": name,
                "default_points": row_widgets["points_var"].get(),
                "contributes_to_total": row_widgets["to_total_var"].get(),
                "is_extra_credit": row_widgets["is_bonus_var"].get()
            })
        
        # Check if actual changes were made before setting the flag
        if self.mark_types_ref != updated_list: # Simple list comparison
            self.mark_types_ref[:] = updated_list # Replace content of original list
            self.mark_types_changed = True
        
        # self.mark_types_changed flag is now set if there were modifications.

class ManageLiveSelectOptionsDialog(simpledialog.Dialog):
    def __init__(self, parent, current_options_list):
        self.current_options = [opt.copy() for opt in current_options_list] # Work on a copy
        self.options_changed_flag = False
        super().__init__(parent, "Manage 'Select' Mode Options for Live Homework")

    def body(self, master):
        self.main_frame = master
        ttk.Label(master, text="Define the buttons/options available in 'Select' mode for live homework sessions.", wraplength=350).pack(pady=5)
        
        button_frame = ttk.Frame(master); button_frame.pack(fill=tk.X, pady=5)
        ttk.Button(button_frame, text="Add New Option", command=self.add_option).pack(side=tk.LEFT, padx=5)

        self.list_frame = ttk.Frame(master); self.list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        self.populate_options_ui()
        return self.main_frame

    def populate_options_ui(self):
        for widget in self.list_frame.winfo_children(): widget.destroy()
        
        self.option_entry_vars = [] # List of StringVars for names

        for r_idx, option_dict in enumerate(self.current_options):
            option_frame = ttk.Frame(self.list_frame); option_frame.pack(fill=tk.X, pady=2)
            
            name_var = tk.StringVar(value=option_dict.get("name","")); self.option_entry_vars.append(name_var)
            name_entry = ttk.Entry(option_frame, textvariable=name_var, width=30)
            name_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
            
            del_btn = ttk.Button(option_frame, text="Remove", command=lambda idx=r_idx: self.delete_option_at_index(idx), width=8)
            del_btn.pack(side=tk.LEFT, padx=5)
        
        if not self.current_options:
            ttk.Label(self.list_frame, text="No options defined. Click 'Add New Option'.").pack(pady=10)

    def add_option(self):
        if len(self.current_options) >= MAX_CUSTOM_TYPES: # Use a reasonable limit
            messagebox.showwarning("Limit Reached", "Maximum number of 'Select' options reached.", parent=self); return
        
        new_name = simpledialog.askstring("New Option", "Enter name for the new option (e.g., 'Signed', 'Returned Late'):", parent=self)
        if new_name and new_name.strip():
            new_name_clean = new_name.strip()
            if any(opt.get("name","").lower() == new_name_clean.lower() for opt in self.current_options):
                messagebox.showwarning("Duplicate Name", f"An option named '{new_name_clean}' already exists.", parent=self); return
            self.current_options.append({"name": new_name_clean})
            self.options_changed_flag = True
            self.populate_options_ui()

    def delete_option_at_index(self, index):
        if 0 <= index < len(self.current_options):
            if messagebox.askyesno("Confirm Delete", f"Delete option '{self.current_options[index]['name']}'?", parent=self):
                del self.current_options[index]
                self.options_changed_flag = True
                self.populate_options_ui()

    def apply(self):
        updated_options = []
        for name_var in self.option_entry_vars:
            name = name_var.get().strip()
            if not name:
                messagebox.showerror("Invalid Name", "Option names cannot be empty.", parent=self); return
            if any(opt.get("name","") == name for opt in updated_options): # Check for duplicates within the new list
                messagebox.showerror("Duplicate Name", f"Option name '{name}' is duplicated in the list. Names must be unique.", parent=self); return
            updated_options.append({"name": name})
        
        # Compare with original to see if actual changes occurred
        # Simple comparison might fail if order changed but content is same.
        # For now, if any entry var changed from initial or list length changed, consider it changed.
        # The self.options_changed_flag handles additions/deletions. This apply covers edits.
        if self.current_options != updated_options: # If direct edits changed things
            self.options_changed_flag = True
        self.current_options = updated_options # Finalize list


class HelpDialog(simpledialog.Dialog):
    def __init__(self, parent, app_version):
        self.app_version = app_version
        super().__init__(parent, f"Help & About - {APP_NAME}")

    def body(self, master):
        main_frame = ttk.Frame(master); main_frame.pack(expand=True, fill="both")
        
        header_label = ttk.Label(main_frame, text=f"{APP_NAME} - Version {self.app_version}", font=("", 14, "bold"))
        header_label.pack(pady=(10,5))
        
        notebook = ttk.Notebook(main_frame)
        
        # --- General Info Tab ---
        info_tab = ttk.Frame(notebook, padding=10)
        info_text_content = f"""Welcome to {APP_NAME}!

This application helps you track student behaviors, quiz scores, and homework completion in a visual classroom layout.

Key Features:
- Visual seating chart: Drag and drop students and furniture.
- Behavior Logging: Quickly log predefined or custom behaviors for students.
- Quiz Logging: Record quiz scores, including detailed marks.
- Homework Logging: Track homework status via manual logs or live sessions.
- Live Sessions: Conduct real-time quiz or homework checks directly on the seating chart.
- Customization: Define your own behaviors, homework types, mark types, and layout templates.
- Data Export: Export logs to Excel or CSV for reporting and analysis.
- Undo/Redo: Most actions can be undone and redone.
- Password Protection: Secure your application data.
- Data Backup & Restore: Keep your classroom data safe.

Navigation & Interaction Tips:
- Canvas Panning: Middle-click and drag to pan the seating chart.
- Canvas Zoom: Ctrl + Mouse Wheel to zoom in/out. Shift + Mouse Wheel for horizontal scroll.
- Multi-Select: Ctrl + Left-click to select multiple items.
- Context Menus: Right-click on items or the canvas for quick actions.
- Edit Mode: Toggle "Edit Mode (Resize)" to resize items by dragging their bottom-right corner.
- Combobox Scrolling: You can often use the mouse wheel to scroll through options in dropdown (combobox) lists, even if a scrollbar isn't visible.
- Data Files: Your classroom data is stored locally. Use 'File > Open Data Folder' to access these files. Regularly backup using 'File > Backup All Application Data'.
"""
        info_text = tk.Text(info_tab, wrap="word", height=20, width=70, relief=tk.FLAT, font=('Arial',11))
        info_text.insert("1.0", info_text_content)
        info_text.config(state="disabled")
        info_text.pack(pady=5, fill="both", expand=True)
        notebook.add(info_tab, text="General Info")

        # --- Modes Tab ---
        modes_tab = ttk.Frame(notebook, padding=10)
        modes_text_content = f"""Application Modes:

The application operates in three main modes, selectable from the top toolbar:

1. Behavior Mode:
   - Default mode for general classroom management.
   - Clicking a student allows logging of behaviors (e.g., "Talking", "Great Participation").
   - Recent behavior logs can be displayed on student boxes.

2. Quiz Mode:
   - Focused on quiz-related activities.
   - Clicking a student allows logging of a quiz score with detailed marks.
   - Live Quiz Session:
     - Start a "Class Quiz" session to mark students' answers (Correct/Incorrect/Skip) in real-time.
     - Scores are displayed live on student boxes.
     - Session data is logged upon ending the session.
   - Quiz Templates: Define reusable quiz structures (name, number of questions, default marks) in Settings.

3. Homework Mode (New!):
   - Dedicated to tracking homework.
   - Clicking a student allows:
     - Manual Logging: Log detailed homework status (e.g., "Done", "Not Done", "Signed") and optionally record marks/scores if enabled in settings.
     - Live Homework Session:
       - Start a "Homework Session" (e.g., "Daily Homework Check").
       - Session Mode (configurable in Settings > Homework):
         - "Yes/No" Mode: Quickly mark predefined homework types (e.g., "Reading Assignment: Yes/No", "Math Worksheet: Yes/No"). Define these types in Settings > Homework.
         - "Select" Mode: Choose from a list of predefined statuses (e.g., "Done", "Signed", "Missing"). Define these options in Settings > Homework.
       - Statuses are displayed live on student boxes.
       - Session data is logged upon ending.
   - Homework Templates: Define reusable homework assignments (name, number of items, default marks/statuses) in Settings.
   - Recent homework logs can be displayed on student boxes.

Switching Modes:
- If a Live Quiz or Live Homework session is active, you will be prompted to end or discard the session before switching modes or closing the application.
"""
        modes_text = tk.Text(modes_tab, wrap="word", height=20, width=70, relief=tk.FLAT, font=('Arial',11))
        modes_text.insert("1.0", modes_text_content)
        modes_text.config(state="disabled")
        modes_text.pack(pady=5, fill="both", expand=True)
        notebook.add(modes_tab, text="Application Modes")

        # --- Settings & Customization Tab ---
        settings_tab = ttk.Frame(notebook, padding=10)
        settings_text_content = f"""Settings & Customization:

The "Settings" dialog allows extensive customization:

- General: Autosave interval, grid snapping, student group feature toggle, max undo history.
- Student Boxes: Default appearance (size, colors, font), and Conditional Formatting rules (e.g., change box color if a student is in a specific group or has many recent incidents).
- Behavior & Quiz:
    - Recent Incidents Display: Control how behavior/quiz logs appear on student boxes.
    - Custom Behaviors: Add your own behavior types.
    - Behavior/Quiz Initials: Customize the initials displayed for behaviors/quizzes.
    - Quiz Mark Types: Define the categories for quiz marks (e.g., Correct, Incorrect, Bonus) and their properties.
    - Quiz Session Defaults: Default quiz name, number of questions for manual log.
    - Quiz Templates: Manage reusable quiz structures.
- Homework (New!):
    - Recent Homework Display: Control how homework logs appear on student boxes.
    - Custom Homework Log Options: Define statuses for manual homework logging (e.g., "Done", "Not Done", "Late").
    - Homework Log Initials: Customize initials for homework log entries.
    - Homework Mark Types: Define categories for homework marks (e.g., Complete, Incomplete, Effort Score) and their properties.
    - Live Homework Session:
        - Default session name.
        - Session Mode: Choose between "Yes/No" or "Select".
        - Custom Types for "Yes/No" Mode: Define the list of homeworks to check (e.g., "Reading", "Math").
        - Options for "Select" Mode: Define the buttons available (e.g., "Done", "Signed").
    - Enable Detailed Marks: Toggle whether to log detailed scores/marks for manual homework entries.
    - Homework Templates: Manage reusable homework assignment structures.
- Data & Export: Default options for Excel export (separate sheets, include summary). Enable experimental Excel autosave.
- Security: Set an application password, configure password prompts (on open, for sensitive actions), and auto-lock settings.

Remember to save your settings after making changes!
"""
        settings_text = tk.Text(settings_tab, wrap="word", height=20, width=70, relief=tk.FLAT, font=('Arial',11))
        settings_text.insert("1.0", settings_text_content)
        settings_text.config(state="disabled")
        settings_text.pack(pady=5, fill="both", expand=True)
        notebook.add(settings_tab, text="Settings & Customization")
        
         # --- Settings & Customization Tab ---
        remarks_tab = ttk.Frame(notebook, padding=10)
        remarks_text_content = f"""
        Please note the following:
        
- The 'Export Layout as Image' function currently only takes a screenshot of the entire window. Hopefully soon I will be able to make it functional.
- I am still working on the homework logging and exporting - so expect to see more features, and don't be surprised if something doesn't work as expected.
- The Conditional Formatting feature currently doesn't work for quizzes. If you have two rules that apply to the same student box, the first one will take precedent.
    -Yaakov Maimon
"""        
        remarks_text = tk.Text(remarks_tab, wrap="word", height=20, width=70, relief=tk.FLAT, font=('Arial',11))
        remarks_text.insert("1.0", remarks_text_content)
        remarks_text.config(state="disabled")
        remarks_text.pack(pady=5, fill="both", expand=True)
        notebook.add(remarks_tab, text="Remarks & Notices")
        
        # --- Feedback & Contact Tab ---
        feedback_tab = ttk.Frame(notebook, padding=10)
        feedback_text_content = f"""                                                    Contact the developer:
        
Yaakov Maimon
Email: yaakovmaimon592@gmail.com
Phone: +1 206-750-5557

"""
        feedback_text = tk.Text(feedback_tab, wrap="word", height=20, width=70, relief=tk.FLAT, font=('Arial',11))
        feedback_text.insert("1.0", feedback_text_content)
        feedback_text.config(state="disabled")
        feedback_text.pack(pady=5, fill="both", expand=True)
        notebook.add(feedback_tab, text="Feedback")
        

        notebook.pack(expand=True, fill="both", pady=5)
        return main_frame # No specific focus needed

    def buttonbox(self): # Override to only show an OK button
        box = ttk.Frame(self)
        ok_button = ttk.Button(box, text="OK", width=10, command=self.ok, default=tk.ACTIVE)
        ok_button.pack(pady=5)
        self.bind("<Return>", self.ok)
        self.bind("<Escape>", self.ok)
        box.pack()

# --- File Lock Manager ---
class FileLockManager:
    def __init__(self, lock_file_path):
        self.lock_file_path = lock_file_path
        self.lock = None

    def acquire_lock(self):
        try:
            # Open the lock file in exclusive mode, creating it if it doesn't exist.
            # portalocker will raise an exception if the lock cannot be acquired.
            self.lock = open(self.lock_file_path, 'w')
            portalocker.lock(self.lock, portalocker.LOCK_EX | portalocker.LOCK_NB)
            # Write PID to lock file for informational purposes (optional)
            self.lock.write(str(os.getpid()))
            self.lock.flush()
            return True
        except ( IOError, BlockingIOError) as e:
            # Check if lock file exists and try to read PID
            pid_in_lock = None
            if os.path.exists(self.lock_file_path):
                try:
                    with open(self.lock_file_path, 'r') as f_read:
                        pid_in_lock = f_read.read().strip()
                except IOError:
                    pass # Could not read PID
            
            error_message = f"Another instance of {APP_NAME} may already be running."
            if pid_in_lock:
                error_message += f" (PID in lock file: {pid_in_lock})"
            else:
                error_message += " (Could not read PID from lock file)."
            error_message += f"\n\nIf you are sure no other instance is running, you can manually delete the lock file:\n{self.lock_file_path}\n\nError details: {e}"
            
            messagebox.showerror("Application Already Running?", error_message)
            if self.lock: # Close the file handle if it was opened but locking failed
                portalocker.unlock(self.lock)
                self.lock.close()
                self.lock = None
            return False
        
    def release_lock(self):
        if self.lock:
            try:
                portalocker.unlock(self.lock)
                self.lock.close()
            except Exception as e:
                print(f"Warning: Error releasing file lock: {e}")
            finally:
                self.lock = None
                # Attempt to delete the lock file
                try:
                    if os.path.exists(self.lock_file_path):
                        os.remove(self.lock_file_path)
                except OSError as e:
                    print(f"Warning: Could not delete lock file {self.lock_file_path}: {e}")
# --- Password Management ---
class PasswordManager:
    def __init__(self, app_settings):
        self.app_settings = app_settings
        self.is_locked = False
        self.last_activity_time = datetime.now()

    def _hash_password(self, password):
        return hashlib.sha3_512(password.encode('utf-8')).hexdigest()

    def set_password(self, password):
        if not password:
            self.app_settings["app_password_hash"] = None
            return True
        self.app_settings["app_password_hash"] = self._hash_password(password)
        return True

    def check_password(self, password):
        stored_hash = self.app_settings.get("app_password_hash")
        if not stored_hash: return True
        return self._hash_password(password) == stored_hash

    def check_recovery_password(self, recovery_password):
        return self._hash_password(recovery_password) == MASTER_RECOVERY_PASSWORD_HASH

    def is_password_set(self):
        return bool(self.app_settings.get("app_password_hash"))

    def lock_application(self):
        if self.is_password_set():
            self.is_locked = True
            return True
        return False

    def unlock_application(self, password_attempt):
        if self.check_password(password_attempt) or self.check_recovery_password(password_attempt):
            self.is_locked = False
            self.last_activity_time = datetime.now()
            return True
        return False

    def check_auto_lock(self):
        if self.is_locked or not self.is_password_set() or not self.app_settings.get("password_auto_lock_enabled", False):
            return
        timeout_minutes = self.app_settings.get("password_auto_lock_timeout_minutes", 15)
        if timeout_minutes > 0:
            if (datetime.now() - self.last_activity_time).total_seconds() / 60 > timeout_minutes:
                self.lock_application()

    def record_activity(self):
        self.last_activity_time = datetime.now()



    """
    def _ensure_next_ids(self):
        # Student IDs
        max_s_id = 0
        for sid in self.students:
            if sid.startswith("student_"):
                try: max_s_id = max(max_s_id, int(sid.split("_")[1]))
                except (ValueError, IndexError): pass
        self.next_student_id_num = max(self.settings.get("next_student_id_num", 1), max_s_id + 1)
        self.settings["next_student_id_num"] = self.next_student_id_num

        # Furniture IDs
        max_f_id = 0
        for fid in self.furniture:
            if fid.startswith("furniture_"):
                try: max_f_id = max(max_f_id, int(fid.split("_")[1]))
                except (ValueError, IndexError): pass
        self.next_furniture_id_num = max(self.settings.get("next_furniture_id_num", 1), max_f_id + 1)
        self.settings["next_furniture_id_num"] = self.next_furniture_id_num

        # Group IDs
        max_g_id = 0
        for gid in self.student_groups:
            if gid.startswith("group_"):
                try: max_g_id = max(max_g_id, int(gid.split("_")[1]))
                except (ValueError, IndexError): pass
        self.next_group_id_num = max(self.settings.get("next_group_id_num", 1), max_g_id + 1)
        self.settings["next_group_id_num"] = self.next_group_id_num

        # Quiz Template IDs
        max_qt_id = 0
        for qtid in self.quiz_templates:
            if qtid.startswith("quiztemplate_"):
                try: max_qt_id = max(max_qt_id, int(qtid.split("_")[1]))
                except (ValueError, IndexError): pass
        self.next_quiz_template_id_num = max(self.settings.get("next_quiz_template_id_num", 1), max_qt_id + 1)
        self.settings["next_quiz_template_id_num"] = self.next_quiz_template_id_num

        # Homework Template IDs (New)
        max_ht_id = 0
        for htid in self.homework_templates:
            if htid.startswith("hwtemplate_"): # Consistent prefix
                try: max_ht_id = max(max_ht_id, int(htid.split("_")[1]))
                except (ValueError, IndexError): pass
        self.next_homework_template_id_num = max(self.settings.get("next_homework_template_id_num", 1), max_ht_id + 1)
        self.settings["next_homework_template_id_num"] = self.next_homework_template_id_num

        # Custom Homework Type IDs (for Yes/No mode live session) - New
        max_chwt_id = 0
        for chwt in self.custom_homework_session_types: # Assuming these are dicts with an 'id' field
            if isinstance(chwt, dict) and chwt.get('id', '').startswith("hwtype_"):
                try: max_chwt_id = max(max_chwt_id, int(chwt['id'].split("_")[1]))
                except (ValueError, IndexError): pass
        self.settings["next_custom_homework_type_id_num"] = max(self.settings.get("next_custom_homework_type_id_num", 1), max_chwt_id + 1)
    """
   